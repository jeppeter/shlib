#! /usr/bin/env python

import os
import extargsparse
import logging
import re
import sys


def read_file(infile=None):
    s = ''
    fin = sys.stdin
    if infile is not None:
        fin = open(infile,'rb')
    for l in fin:
        if sys.version[0] == '2':
            s += l
        else:
            s += l.decode(encoding='UTF-8')
    if fin != sys.stdin:
        fin.close()
    fin = None
    return s

def write_retfile(file,lines):
    s = ''
    if file is not None:
        with open(file,'ab') as f:
            for l in lines:
                f.write('%s\n'%(l))
    for l in lines:
        s += '%s\n'%(l)
    return s

def output_string(s,outfile=None):
    fout = sys.stdout
    if outfile is not None:
        fout = open(outfile,'wb')
    fout.write('%s'%(s))
    if fout != sys.stdout:
        fout.close()
    fout = None
    return

class _OptionAccess(object):
    def __init__(self):
        self.__accessed = dict()
        return

    def __setattr__(self,k,v):
        if k.startswith('_'):
            self.__dict__[k]=v
            return
        self.__accessed[k] = True
        return

    def __getattr__(self,k,defv=None):
        if k.startswith('_'):
            if k not in self.__dict__.keys():
                return defv
            return self.__dict__[k]
        if k not in self.__accessed.keys():
            return False
        return True

    def __format(self):
        s = '['
        for k in self.__accessed.keys():
            s += '%s;'%(k)
        s += ']'
        return s

    def __str__(self):
        return self.__format()

    def __repr__(self):
        return self.__format()

class ResultAttr(object):
    def __init__(self):
        self.__objs = dict()
        return

    def __setattr__(self,k,v):
        if k.startswith('_'):
            self.__dict__[k]=v
            return
        self.__objs[k] = v
        return

    def __getattr__(self,k,defv=None):
        if k.startswith('_'):
            if k not in self.__dict__.keys():
                return defv
            return self.__dict__[k]
        if k  in self.__objs.keys():
            return self.__objs[k]
        return defv

    def __format(self):
        s = '['
        for k in self.__objs.keys():
            s += '%s=%s;'%(k,self.__objs[k])
        s += ']'
        return s

    def __str__(self):
        return self.__format()

    def __repr__(self):
        return self.__format()

class CompleteExtArgs(extargsparse.ExtArgsParse):
    def __init__(self,options=None,priority=None):
        super(CompleteExtArgs,self).__init__(options,priority)
        self.options = options
        if self.options is None:
            self.options = extargsparse.ExtArgOptions()
        if self.options.longprefix is None:
            raise Exception('can not be longprefix null')
        if self.options.shortprefix is not None and self.options.shortprefix == self.options.longprefix:
            self.options.bundled = False
        else:
            self.options.bundled = True
        self.priority = priority
        if priority is None:
            self.priority = [extargsparse.SUB_COMMAND_JSON_SET,extargsparse.COMMAND_JSON_SET,\
                extargsparse.ENVIRONMENT_SET,extargsparse.ENV_SUB_COMMAND_JSON_SET,\
                extargsparse.ENV_COMMAND_JSON_SET]
        self.optaccess = _OptionAccess()

        self.leftargs = []
        self.__ended = 0
        self.__curidx = 1
        self.__validx = -1
        self.__curcharidx = -1
        self.__longstep = -1
        self.__shortstep = -1

        self.__laststepopts = []

        self.__step_functions = {
            'string' : self.__string_step,
            'unicode' : self.__string_step,
            'int' : self.__int_step,
            'long' : self.__int_step,
            'float' : self.__float_step,
            'list' : self.__list_step,
            'bool' : self.__bool_step,
            'args' : self.__args_step,
            'command' : self.__command_step,
            'prefix' : self.__prefix_step,
            'count': self.__count_step,
            'help' : self.__help_step,
            'jsonfile' : self.__jsonfile_step
        }
        return

    def warn_override(self,keycls,firstcheck):
        accessed = getattr(self.optaccess,keycls.optdest,None)
        if accessed is not None and firstcheck:
            warns = ''
            warns += '[%s'%(keycls.longopt)
            if keycls.shortopt is not None:
                warns += '|%s'%(keycls.shortopt)
            warns += '] will be override'
            logging.warn('%s'%(warns))
        return

    def set_access(self,keycls):
        setattr(self.optaccess,keycls.optdest,True)
        return

    def __string_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls)
        self.set_access(keycls)
        return 1        

    def __int_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls)
        self.set_access(keycls)
        return 1

    def __long_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls,firstcheck)
        self.set_access(keycls)
        return 1


    def __float_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls,firstcheck)
        self.set_access(keycls)
        return 1

    def __list_step(self,validx,keycls,params,firstcheck):
        self.set_access(keycls)
        return 1

    def __bool_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls,firstcheck)
        self.set_access(keycls)
        return 0

    def __args_step(self,validx,keycls,params,firstcheck):
        self.leftargs.append(params[validx])
        return 1

    def __command_step(self,validx,keycls,params,firstcheck):
        return 0

    def __prefix_step(self,validx,keycls,params,firstcheck):
        return 0

    def __count_step(self,validx,keycls,params,firstcheck):
        self.set_access(keycls)
        return 0

    def __jsonfile_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls,firstcheck)
        if validx < len(params)-1:
            if os.path.isfile(params[validx]):
                warns = ''
                warns += '[%s'%(keycls.longopt)
                if keycls.shortopt is not None:
                    warns += '|%s'%(keycls.shortopt)
                warns += '] set [%s] not valid file'%(params[validx])
                logging.warn('%s'%(warns))
        self.set_access(keycls)
        return 1



    def __help_step(self,validx,keycls,params,firstcheck):
        return -1

    def call_step_func(self,validx,keycls,params,firstcheck=True):
        if keycls.attr is not None and keycls.attr.optparse is not None:
            return self.call_func(keycls.attr.optparse,self,validx,keycls,params,firstcheck)
        return self.__command_step[keycls.type](validx,keycls,params,firstcheck)

    def format_subcmd(self,maincmd,subcmd):
        retcmd = ''
        if maincmd is not None and len(maincmd) > 0:
            retcmd += '%s.'%(maincmd)
        retcmd += subcmd
        return retcmd

    def __get_longopts_cmd(self,curcmd=''):
        longopts = []
        cmdopts = self.get_cmdopts(curcmd)
        for opt in cmdopts:
            if not opt.isflag  or opt.type == 'args':
                continue
            longopts.append(opt.longopt)
        return longopts

    def __get_shortflags_cmd(self,curcmd=''):
        shortflags = []
        cmdopts = self.get_cmdopts(curcmd)
        for opt in cmdopts:
            if not opt.isflag  or opt.type == 'args':
                continue
            if opt.shortflag is not None:
                shortflags.append(opt.shortflag)
        return shortflags


    def __check_uniq(self,sarr,notice=''):
        idx = 0
        while idx < len(sarr):
            if idx >= (len(sarr)-1):
                break
            if sarr[idx] == sarr[(idx+1)]:
                del sarr[idx]
                self.warn('[%s][%d] same'%(notice,idx))
                continue
            idx += 1
        return sarr


    def __get_longopts(self,cmdname=''):
        longopts = []
        sarr = []
        if cmdname is not None and len(cmdname) > 0:
            sarr = re.split('\.',cmdname)
        idx = len(sarr)
        while idx > 0:
            curcmd = '.'.join(sarr[:idx])
            longopts.extend(self.__get_longopts_cmd(curcmd))
            idx -= 1
        longopts.extend(self.__get_longopts_cmd(''))
        longopts = sorted(longopts)
        return self.__check_uniq(longopts,'longopts')

    def __get_shortflags(self,cmdname=''):
        shortflags = []
        sarr = []
        if cmdname is not None and len(cmdname) > 0:
            sarr = re.split('\.',cmdname)
        idx = len(sarr)
        while idx > 0:
            curcmd = '.'.join(sarr[:idx])
            shortflags.extend(self.__get_shortflags_cmd(curcmd))
            idx -= 1
        shortflags.extend(self.__get_shortflags_cmd(''))
        shortflags = sorted(shortflags)
        return self.__check_uniq(shortflags,'shortflags')


    def __get_opt_longopt_cmd(self,longopt,cmdname=''):
        cmdopts = self.get_cmdopts(cmdname)
        for opt in cmdopts:
            if not opt.isflag or opt.type == 'args':
                continue
            if opt.longopt == longopt:
                return opt
        return None

    def __get_opt_longopt(self,longopt,cmdname):
        sarr = []
        if cmdname is not None and len(cmdname) > 0:
            sarr = re.split('\.',cmdname)
        idx = len(sarr)
        while idx > 0:
            curcmd = '.'.join(sarr[:idx])
            curopt = self.__get_opt_longopt_cmd(longopt,curcmd)
            if curopt is not None:
                return curopt
            idx -= 1
        return self.__get_opt_longopt_cmd(longopt,'')


    def __get_opt_shortflag_cmd(self,shortflag,cmdname=''):
        cmdopts = self.get_cmdopts(cmdname)
        for opt in cmdopts:
            if not opt.isflag or opt.type == 'args':
                continue
            if opt.shortflag is not None and opt.shortflag == shortflag:
                return opt
        return None

    def __get_opt_shortflag(self,shortflag,cmdname):
        sarr = []
        if cmdname is not None and len(cmdname) > 0:
            sarr = re.split('\.',cmdname)
        idx = len(sarr)
        while idx > 0:
            curcmd = '.'.join(sarr[:idx])
            curopt = self.__get_opt_shortflag_cmd(shortflag,curcmd)
            if curopt is not None:
                return curopt
            idx -= 1
        return self.__get_opt_shortflag_cmd(shortflag,'')

    def __step_longopt(self,must=False):
        need = must
        if not need and self.__longstep >= 0:
            need = True
        if need:
            assert(self.__longstep >= 0)
            assert(self.__validx > 0)
            assert(self.__shortstep < 0)
            assert(self.__curcharidx < 0)
            self.__curidx += self.__longstep
            self.__validx = -1
            self.__longstep = -1
        return self.__curidx

    def __step_shortopt(self,must=True):
        need = must
        if not need and self.__shortstep >= 0:
            need = True
        if need:
            assert(self.__curcharidx >= 0)
            if self.__shortstep >= 0:
                # we maybe use some bad options , so we need any error
                self.__curidx += self.__shortstep
            self.__valid = -1
            self.__shortstep = -1
            self.__curcharidx = -1
        return self.__curidx

    def __get_cmd_step(self,cmdname,params):
        if self.__ended > 0:
            return cmdname,None
        oldidx = self.__step_longopt(False)
        oldcharidx = self.__curcharidx
        while True:
            if oldidx >= len(params):
                self.__ended = 1
                self.__curidx = oldidx
                self.__validx = oldidx
                self.__longstep = -1
                self.__shortstep = -1
                self.__curcharidx = -1
                return cmdname,None

            curopt = params[oldidx]
            if curopt == '--':
                if (oldidx + 1) < len(params):
                    self.leftargs.extend(params[(oldidx+1):])
                self.__curidx = len(params)
                self.__validx = len(params)
                assert(self.__shortstep < 0)
                assert(self.__curcharidx < 0)
                self.__ended = 1
                return cmdname,None
            if oldcharidx > 0:
                while oldcharidx < len(curopt):
                    curch = curopt[oldcharidx]
                    if curch in self.__get_shortflags(curch,cmdname):
                        opt = self.__get_opt_shortflag(curch,cmdname)
                        self.__curidx = oldidx
                        self.__curcharidx = oldcharidx
                        self.__validx = (oldidx + 1)
                        return cmdname,opt
                    else:
                        self.warn('[%d][%d] [%s] not in the options'%(oldidx,oldcharidx,curch))
                    oldcharidx += 1

                if len(curopt) <= oldcharidx:
                    oldidx = self.__step_shortopt(True)
                    oldcharidx = self.__curcharidx
                    # we get the next one
                    continue
            else:
                if self.options.bundled:
                    if curopt.startswith(self.options.longprefix):
                        if curopt in self.__get_longopts(cmdname):
                            opt = self.__get_opt_longopt(curopt,cmdname)
                            self.__curidx = oldidx
                            self.__validx = (oldidx + 1)
                            return cmdname,opt
                        else:
                            if self.options.parseall:
                                self.warn('[%d] [%s] not supported'%(oldidx,curopt))
                                self.leftargs.append(params[oldidx])
                                oldidx += 1
                                oldcharidx = -1
                                assert(self.__longstep < 0)
                                assert(self.__shortstep < 0)
                                continue
                            # that is ended
                            self.leftargs.extend(params[oldidx:])
                            self.__curidx = len(params)
                            self.__curcharidx = -1
                            self.__validx = len(params)
                            self.__ended = 1
                            assert(self.__longstep < 0)
                            assert(self.__shortstep < 0)
                            return cmdname,None
                    elif self.options.shortprefix is not None and curopt.startswith(self.options.shortprefix):
                        oldcharidx = len(self.options.shortprefix)
                        while oldcharidx < len(curopt):
                            curch = curopt[oldcharidx]
                            if curch in self.__get_shortflags(curch,cmdname):
                                opt = self.__get_opt_shortflag(curch,cmdname)
                                self.__curidx = oldidx
                                self.__curcharidx = oldcharidx
                                self.__validx = (oldidx + 1)
                                return cmdname,opt,False
                            else:
                                if oldidx < (len(params) - 1):
                                    self.warn('[%d][%d] [%s] not in the options'%(oldidx,oldcharidx,curch))
                            oldcharidx += 1

                        if len(curopt) <= oldcharidx:
                            if self.__shortstep < 0:                                
                                # this means that nothing in the more
                                if not self.options.parseall:
                                    self.options.extend(params[oldidx:])
                                    self.__curidx = len(params)
                                    self.__validx = len(params)
                                    assert(self.__longstep < 0)
                                    self.__curcharidx = -1
                                    self.__ended = 1
                                    return cmdname,None
                                # parse all ,so add it to the command
                                self.leftargs.append(params[oldidx])
                            oldidx = self.__step_shortopt(True)
                            oldcharidx = self.__curcharidx
                            # we get the next one
                            continue
                else:
                    # not bundle ,because this is the long and short prefix
                    shortlen = len(self.options.longprefix)
                    if len(curopt) > (shortlen + 1) and curopt.startswith(self.options.longprefix):
                        if curopt in self.__get_longopts(cmdname):
                            opt = self.__get_opt_longopt(curopt,cmdname)
                            self.__curidx = oldidx
                            self.__validx = (oldidx + 1)
                            return cmdname,opt,False
                        else:
                            if self.options.parseall:
                                if oldidx < (len(params) - 1):
                                    self.warn('[%d] [%s] not supported'%(oldidx,curopt))
                                self.leftargs.append(params[oldidx])
                                oldidx += 1
                                oldcharidx = -1
                                assert(self.__longstep < 0)
                                assert(self.__shortstep < 0)
                                continue
                            # that is ended
                            self.leftargs.extend(params[oldidx:])
                            self.__curidx = len(params)
                            self.__curcharidx = -1
                            self.__validx = len(params)
                            self.__ended = 1
                            assert(self.__longstep < 0)
                            assert(self.__shortstep < 0)
                            return cmdname,None

                    if len(curopt) == (shortlen + 1):
                        curch = curopt[shortlen]
                        if curch in self.__get_shortflags(cmdname):
                            opt = self.__get_opt_shortflag(curch,cmdname)
                            self.__curidx = oldidx
                            self.__validx = (oldidx + 1)
                            # make this as the long step
                            self.__curcharidx = -1
                            assert(self.__shortstep < 0)
                            assert(self.__longstep < 0)
                            return cmdname,opt,False
                        else:
                            if self.options.parseall:
                                if oldidx < (len(params) - 1):
                                    self.warn('[%d] [%s] not supported'%(oldidx,curopt))
                                self.leftargs.append(params[oldidx])
                                oldidx += 1
                                oldcharidx = -1
                                assert(self.__longstep < 0)
                                assert(self.__shortstep < 0)
                                continue
                            self.leftargs.extend(params[oldidx:])
                            self.__ended = 1
                            self.__curidx = len(params)
                            self.__validx = len(params)
                            self.__curcharidx = -1
                            assert(self.__shortstep < 0)
                            assert(self.__longstep < 0)
                            return cmdname,None
            # that can not be handled
            subcmds = self.get_subcommands(cmdname)
            if subcmds is not None:
                if params[oldidx] in subcmds:
                    if cmdname is None:
                        cmdname = ''
                    if len(cmdname) > 0:
                        cmdname += '.'
                    cmdname += params[oldidx]
            else:
                if self.options.parseall:
                    self.leftargs.append(params[oldidx])
                else:
                    self.leftargs.extend(params[oldidx:])
                    self.__curidx = len(params)
                    self.__validx = len(params)
                    self.__curcharidx = -1
                    self.__ended = 1
                    assert(self.__shortstep < 0)
                    assert(self.__longstep < 0)
                    return cmdname,None
            oldidx += 1
            oldcharidx = -1
        return cmdname,None

    def __step(self,step,opt):
        if self.__curcharidx >= 0:
            if self.__shortstep < 0:
                self.__shortstep = 0
            if self.__shortstep > 0:
                assert(len(self.__laststepopts) > 0)
                self.warn('[%s] with [%s] conflict'%(self.__laststepopts[-1].shortflag, opt.shortflag))
                self.__shortstep = 0
                self.__laststepopts = []
            self.__shortstep += step
            if step > 0:
                self.__laststepopts.append(opt)
        else:
            if self.__longstep < 0:
                self.__longstep = 0
            assert(self.__longstep == 0)
            self.__longstep += step
        return

    def step_completes(self,args=[]):
        self.optaccess = _OptionAccess()
        self.leftargs = []
        curcmd = ''
        # now we should give the 
        idx = 1
        result = ResultAttr()
        result.stopped = False
        result.lastopt = None
        result.lastidx = None
        while True:
            curcmd,opt = self.__get_cmd_step(curcmd,args)
            if opt is None:
                break
            step = self.call_optfunc(self.__validx,opt,args)
            if step < 0:
                # this means we should end of this
                self.leftargs.extend(args[self.__validx:])
                self.__ended = 1
                self.__validx = len(args)
                self.__curidx = len(args)
                self.__shortstep = -1
                self.__longstep = -1
                self.__curcharidx = -1
                result.stopped = True
                break
            self.__step(step,opt)
            if step > 0:
                result.lastidx = self.__validx
                result.lastopt = opt
        self.__laststepopts = []
        result.cmdname = curcmd
        logging.info('result (%s)'%(result))
        return result

    def completion_call_opt(self,validx,opt,params):
        if opt.attr is not None and opt.attr.completefunc is not None:
            return self.call_func(opt.attr.completefunc,self,validx,opt,params)
        return self.__opt_complete_map[opt.type](validx,opt,params)

    def __get_argsattr(self,cmdname):
        cmdopts = self.get_cmdopts(cmdname)
        for opt in cmdopts:
            if opt.type == 'args':
                return opt
        return None

    def file_common_completion(self,pathpat,filterop=None):
        retfiles = []
        basedir = os.path.dirname(pathpat)
        if len(basedir) == 0:
            basedir = '.'
            appenddir = ''
        else:
            appenddir = basedir
        try:
            for c in os.listdir(basedir):
                ok = True
                if len(appenddir) == 0:
                    ofile = c
                else:
                    ofile = os.path.join(basedir,c)
                if filterop is not None:
                    ok = filterop(ofile)
                if ok and (len(pathpat) == 0 or ofile.startswith(pathpat)):
                    retfiles.append(ofile)
        except:
            # nothing to handle 
            retfiles = []
        return retfiles


    def call_completion_cmd_nargs(self,cmdname,params):
        addmost = -1
        filtername = ''
        if len(params) > 1:
            filtername = params[-1]
        argsattr = self.__get_argsattr(cmdname)
        if argsattr is not None:
            if argsattr.nargs != '+' and argsattr.nargs != '*':
                if argsattr.nargs == '?':
                    addmost = 1
                else:
                    addmost = argsattr.nargs
        retcompletions = []
        if addmost >= 0 and addmost < len(self.leftargs):
            return retcompletions
        if argsattr.attr is not None and argsattr.attr.completefunc is not None:
            retcompletions.extend(self.call_func(argsattr.attr.completefunc,self,cmdname,params))
            return
        curcompletions = self.file_common_completion(filtername,None)
        curcompletions = sorted(curcompletions)
        for c in curcompletions:
            if c.startswith(filtername):
                retcompletions.append(c)
        return retcompletions     


    def completion_call_cmd(self,cmdname,params):
        filtername = ''
        validx = 1
        if len(params) > 1:
            filtername = params[-1]
            validx = len(params) - 1
        retcompletions = []
        hasstepped = False
        if len(filtername) > 0 and filtername.startswith(self.options.shortprefix) \
            and not filtername.startswith(self.options.longprefix) and self.options.bundled:
            idx = len(self.options.shortprefix)
            while idx < len(filtername):
                curch = filtername[idx]
                opt = self.__get_opt_shortflag(curch,cmdname)
                if opt is not None:
                    step = self.call_step_func(validx,opt,params,False)
                    if step > 0:
                        hasstepped = True
                idx += 1
        curcompletions = []

        for l in self.__get_longopts(cmdname):
            if l.startswith(filtername):
                curcompletions.append(l)
        curcompletions = sorted(curcompletions)
        retcompletions.extend(curcompletions)
        curcompletions = []
        if self.options.bundled and self.options.shortprefix is not None:
            if len(filtername) == 0:
                for c in self.__get_shortflags(cmdname):
                    curc = '%s%s'%(self.options.shortprefix,c)
                    curcompletions.append(curc)
            elif filtername.startswith(self.options.shortprefix) and not filtername.startswith(self.options.longprefix) :
                for c in self.__get_shortflags(cmdname):
                    added = True
                    opt = self.__get_opt_shortflag(c,cmdname)
                    if opt is not None and hasstepped:
                        step = self.call_step_func(validx,opt,params,False)
                        if step > 0:
                            added = False
                    if added :
                        curcompletions.append(c)
        elif self.options.shortprefix is not None:
            # this is not bundled ,so we do this ok
            for c in self.__get_shortflags(cmdname):
                curc = '%s%s'%(self.options.shortprefix,c)
                if curc.startswith(filtername):
                    curcompletions.append(curc)
        curcompletions = sorted(curcompletions)
        retcompletions.extend(curcompletions)
        subcmds = self.get_subcommands(cmdname)
        curcompletions = []
        if subcmds is not None:
            for c in subcmds:
                if c.startswith(filtername):
                    curcompletions.append(c)
        curcompletions = sorted(curcompletions)
        retcompletions.extend(curcompletions)
        logging.info('cmdname [%s] params (%s)'%(cmdname,params))        
        curcompletions = self.call_completion_cmd_nargs(cmdname,params)
        curcompletions = sorted(curcompletions)
        logging.info('curcompletions (%s) '%(curcompletions))
        retcompletions.extend(curcompletions)
        return retcompletions

    def __get_completions_cmdname(self,result,params):
        needopt = None
        if result.lastopt is not None and (result.lastidx < (len(params) - 1)):
            step = self.call_step_func(result.lastidx,result.lastopt,params)
            if   (result.lastidx + step) >= len(params):
                # this means that we have not handled all the needed
                needopt = result.lastopt
        if needopt is not None:
            # it means that we need to handle specified handle
            return self.completeion_call(result.lastidx,result.lastopt,params)
        return self.completion_call_cmd(result.cmdname,params)


    def get_completions(self,args=[]):
        result = self.step_completes(args)
        completions = []
        if result.stopped :
            return completions
        completions = self.__get_completions_cmdname(result,args)
        return completions





def __get_argsopt_opt(args,argsopt,subcmdname=None,needargs=True,shortopt=False):
    optret=[]
    opts = argsopt.get_cmdopts(subcmdname)
    if opts is not None:
        for c in opts:
            if c.type != 'args':
                if shortopt :
                    if needargs and c.nargs != 0 and c.shortflag is not None:
                        optret.append(c.shortflag)
                    elif not needargs and c.nargs == 0 and c.shortflag is not None:
                        optret.append(c.shortflag)
                else:
                    if  needargs and c.nargs != 0 :
                        optret.append(c.longopt)
                    elif not needargs and c.nargs == 0:
                        optret.append(c.longopt)
    return optret

def __get_argsopt_optattr(args,argsopt,opt,subcmdname=None):
    opts = argsopt.get_cmdopts(subcmdname)
    if opts is not None:
        if len(opt) == 1:            
            for c in opts:
                if c.type != 'args':
                    if c.shortflag is not None and c.shortflag == opt:
                        return c
        else:
            for c in opts:
                if c.type != 'args':
                    if c.longopt == opt:
                        return c
    return None

def get_argsopt_optattr(args,argsopt,opt,subcmdname=None):
    sarr = []
    if subcmdname is not None and len(subcmdname) > 0:
        sarr= re.split('\.',subcmdname)
    optattr = __get_argsopt_optattr(args,argsopt,opt,None)
    if optattr is not None:
        return optattr
    i = 0
    curcmd = ''
    while i < len(sarr):
        if i > 0:
            curcmd = '%s.%s'%(curcmd,sarr[i])
        else:
            curcmd = sarr[i]
        optattr = __get_argsopt_optattr(args,argsopt,opt,curcmd)
        if optattr is not None:
            return optattr
        i += 1
    return None

def get_argsopt_argsattr(args,argsopt,cmdname=None):
    opts = argsopt.get_cmdopts(cmdname)
    if opts is not None:
        for c in opts:
            if c.type =='args':
                return c
    return None

def __get_argsopt_longopt(args,argsopt,subcmdname=None,needargs=True):
    return __get_argsopt_opt(args,argsopt,subcmdname,needargs,False)

def __get_argsopt_noargs_longopt(args,argsopt,subcmdname=None):
    return __get_argsopt_longopt(args,argsopt,subcmdname,False)

def __get_argsopt_needargs_longopt(args,argsopt,subcmdname=None):
    return __get_argsopt_longopt(args,argsopt,subcmdname,True)

def __get_argsopt_shortopt(args,argsopt,subcmdname=None,needargs=True):
    return __get_argsopt_opt(args,argsopt,subcmdname,needargs,True)

def get_argsopt_opt(args,argsopt,cmdname=None,needargs=True,shortopt=False):
    sarr = []
    if cmdname is not None and len(cmdname) > 0:
        sarr = re.split('\.',cmdname)
    optret = []
    optret.extend(__get_argsopt_opt(args,argsopt,None,needargs,shortopt))
    if len(sarr) > 0:
        i = 0
        cmdname = ''
        while i < len(sarr):
            if i > 0:
                cmdname='%s.%s'%(cmdname,sarr[i])
            else:
                cmdname=sarr[i]
            optret.extend(__get_argsopt_opt(args,argsopt,cmdname,needargs,shortopt))
            i += 1
    return optret

def get_argsopt_longopt(args,argsopt,cmdname=None,needargs=True):
    return get_argsopt_opt(args,argsopt,cmdname,needargs,False)

def get_argsopt_needargs_longopt(args,argsopt,cmdname=None):
    return get_argsopt_longopt(args,argsopt,cmdname,True)

def get_argsopt_noargs_longopt(args,argsopt,cmdname=None):
    return get_argsopt_longopt(args,argsopt,cmdname,False)

def get_argsopt_shortopt(args,argsopt,cmdname=None,needargs=True):
    return get_argsopt_opt(args,argsopt,cmdname,needargs,True)

def get_argsopt_needargs_shortopt(args,argsopt,cmdname=None):
    return get_argsopt_shortopt(args,argsopt,cmdname,True)

def get_argsopt_noargs_shortopt(args,argsopt,cmdname=None):
    return get_argsopt_shortopt(args,argsopt,cmdname,False)

def get_argsopt_subcommand(args,argsopt,cmdname=None):
    return argsopt.get_subcommands(cmdname)

def set_argsopt_optattr(args,argsopt,optname,cmdname,optattr):
    opt = get_argsopt_optattr(args,argsopt,optname,cmdname)
    if opt is not None and opt.type != 'list':
        setattr(optattr,opt.optdest,True)
        if opt.shortflag is not None:
            setattr(optattr,opt.shortflag,True)
    return optattr


def get_command_name(args,argsopt,resfile,optattr,cmds):
    i=1
    maxwords = len(cmds) - 1
    retcmd=''
    errors = ''
    while i < maxwords:
        curcmd = cmds[i]
        i += 1
        if curcmd == '--':
            retcmd='+%d-%s'%((i-1),retcmd)
            break
        if argsopt.options.shortprefix is None or \
            args.options.shortprefix != args.options.longprefix:
            if curcmd.startswith(argsopt.options.longprefix):
                if curcmd in get_argsopt_needargs_longopt(args,argsopt,retcmd):
                    i += 1
                    set_argsopt_optattr(args,argsopt,curcmd,retcmd,optattr)
                elif curcmd in get_argsopt_noargs_longopt(args,argsopt,retcmd):
                    set_argsopt_optattr(args,argsopt,curcmd,retcmd,optattr)
                else:
                    logging.info('[%d][%s] not valid opts'%(i,curcmd))
                    retcmd='--'
                    errors += write_retfile(resfile,['[%d] not valid [%s]'%((i-1),curcmd),'please check opt'])
                    break
        elif curcmd.startswith('-'):
            j = 1
            shortstep = 0
            while j < len(curcmd):
                curch = curcmd[j]
                if curch in get_argsopt_needargs_shortopt(args,argsopt,retcmd):
                    if shortstep > 0:
                        logging.info('[%d][%d][%s] multiple need args for opt'%(i,j,curch))
                        retcmd='--'
                        errors += write_retfile(resfile,['[%d][%s] multiple need args defined'%(i,curcmd),'please check for options use -h|--help'])
                        break
                    shortstep += 1
                    set_argsopt_optattr(args,argsopt,curcmd,retcmd,optattr)
                elif curch in get_argsopt_noargs_shortopt(args,argsopt,retcmd):
                    set_argsopt_optattr(args,argsopt,curcmd,retcmd,optattr)
                else:
                    retcmd='--'
                    logging.info('[%d][%d][%s] not defined shortopt'%(i,j,curch))
                    errors += write_retfile(resfile,['[%d][%s] not defined shortopt'%(i,curcmd),'please check for options use -h|--help'])
                    break
                j += 1
            if shortstep > 0:
               i += 1
        else:
            if curcmd in get_argsopt_subcommand(args,argsopt,retcmd):
                if len(retcmd) > 0:
                    retcmd = '%s.%s'%(retcmd,curcmd)
                else:
                    retcmd = curcmd
            else:
                retcmd = '+%d-%s'%((i-1),retcmd)
                break
    return retcmd,errors
                

def remove_file(args,infile):
    logging.info('remove [%s]'%(infile))
    if infile is not None and not args.reserved and os.path.exists(infile):
        os.remove(infile)
    return


def __get_argsopt_optfunc_opt(args,argsopt,opt,cmdname=None,shortflag=False):
    optfunc = None
    opts = argsopt.get_cmdopts(cmdname)
    if opts is not None:
        for c in opts:
            if c.type != 'args':                
                if not shortflag and c.longopt == opt:
                    if c.attr is not None:
                        if c.attr.optfunc is not None:
                            optfunc = c.attr.optfunc
                    break
                elif shortflag and c.shortflag is not None and c.shortflag == opt:
                    if c.attr is not None:
                        if c.attr.optfunc is not None:
                            optfunc = c.attr.optfunc
                    break
    return optfunc

def get_argsopt_optfunc_opt(args,argsopt,opt,cmdname=None,shortflag=False):
    sarr = []
    optfunc = None
    if cmdname is not None and len(cmdname) > 0:
        sarr = re.split('\.',cmdname)

    optfunc = __get_argsopt_optfunc_opt(args,argsopt,opt,None,shortflag)
    if optfunc is not None:
        return optfunc
    i = 0
    curcmd = ''
    while i < len(sarr):
        if i > 0:
            curcmd = '%s.%s'%(curcmd,sarr[i])
        else:
            curcmd='%s'%(sarr[i])
        optfunc = __get_argsopt_optfunc_opt(args,argsopt,opt,curcmd,shortflag)
        if optfunc is not None:
            return optfunc
        i += 1
    return None

def get_argsopt_optfunc_shortopt(args,argsopt,shortopt,cmdname=None):
    return get_argsopt_optfunc_opt(args,argsopt,shortopt,cmdname,True)

def get_argsopt_optfunc_longopt(args,argsopt,longopt,cmdname=None):
    return get_argsopt_optfunc_opt(args,argsopt,longopt,cmdname,False)

def get_argsopt_cmdfunc(args,argsopt,cmdname=None):
    cmdfunc = None
    opts = argsopt.get_cmdopts(cmdname)
    if opts is not None:
        for c in opts:
            if c.type == 'args':
                if c.attr is not None and c.attr.optfunc is not None:
                    cmdfunc=c.attr.optfunc
                    break
    return cmdfunc

def call_optfunc(funcname,args,argsopt,resfile,cmdidx,cmdname,optattr,totalargs):
    s = ''
    m = importlib.import_module('__main__')
    if m is not None:
        funcptr = getattr(m,funcname,None)
        if funcptr is not None or not hasattr(funcptr,'__call__'):
            raise Exception('%s not defined '%(funcname))
        s = funcptr(args,argsopt,resfile,cmdidx,cmdname,optattr,totalargs)
    return s

def file_filter(p):
    return os.path.isfile(p)

def dir_filter(p):
    return os.path.isdir(p)

def file_common_completion(pathpat,filterop=None):
    retfiles = []
    basedir = os.path.dirname(pathpat)
    if len(basedir) == 0:
        basedir = '.'
        appenddir = ''
    else:
        appenddir = basedir
    try:
        for c in os.listdir(basedir):
            ok = True
            if len(appenddir) == 0:
                ofile = c
            else:
                ofile = os.path.join(basedir,c)
            if filterop is not None:
                ok = filterop(ofile)
            if ok and (len(pathpat) == 0 or ofile.startswith(pathpat)):
                retfiles.append(ofile)
    except:
        # nothing to handle 
        retfiles = []
    return retfiles


def all_file_completion(args,argsopt,resfile,cmdidx,cmdname,leftargs,totalargs):
    pathpat= ''
    if len(totalargs) > 1:
        pathpat = totalargs[-1]
    retfiles = file_common_completion(pathpat,None)
    logging.info('retfiles (%s)'%(retfiles))
    return write_retfile(resfile,retfiles)

def basic_common_completion_opt(longopt,args,argsopt,resfile,cmdidx,cmdname,optattr,totalargs):
    s = ''
    optattr = get_argsopt_optattr(args,argsopt,longopt,cmdname)
    if optattr is None:
        raise Exception('inner error in [%s] longopt'%(longopt))
    if optattr.type == 'int' or optattr.type == 'long':
        s += write_retfile(resfile,['int %s...'%(totalargs[-1]),'[%s] handle'%(longopt)])
        return s
    elif optattr.type == 'float':
        s += write_retfile(resfile,['float %s...'%(totalargs[-1]),'[%s] handle'%(longopt)])
        return s
    elif optattr.type == 'jsonfile' or optattr.type == 'string' \
        or optattr.type == 'list' or optattr.type == 'unicode':
        s += all_file_completion(args,argsopt,resfile,cmdidx,cmdname,leftargs,totalargs)
        return s
    return s

def basic_common_completion_withoutopt(args,argsopt,resfile,cmdidx,cmdname,leftargs,totalargs):
    argsattr = get_argsopt_argsattr(args,argsopt,cmdname)
    if argsattr is not None:
        if argsattr.nargs == '0':
            # we do not output any output
            return ''
    return all_file_completion(args,argsopt,resfile,cmdidx,cmdname,leftargs,totalargs)

def basic_common_completion_option(args,argsopt,resfile,cmdidx,cmdname,optattr,totalargs):
    lastarg = ''
    outputargs = []
    if len(totalargs) > 1:
        lastarg = totalargs[-1]
    logging.info('start need args longopt')
    for c in get_argsopt_needargs_longopt(args,argsopt,cmdname):
        if  (len(lastarg) == 0 or c.startswith(lastarg)):
            opta = get_argsopt_optattr(args,argsopt,c,cmdname)
            if opta is not None and  not getattr(optattr,opta.optdest,False):
                logging.info('add [%s]'%(c))
                outputargs.append(c)
    logging.info('start no args longopt')
    for c in get_argsopt_noargs_longopt(args,argsopt,cmdname):
        if len(lastarg) == 0 or c.startswith(lastarg):
            opta = get_argsopt_optattr(args,argsopt,c,cmdname)
            if opta is not None and not getattr(optattr,opta.optdest,False):
                logging.info('add [%s]'%(c))
                outputargs.append(c)
    if len(lastarg) == 0 or (lastarg.startswith('-') and not lastarg.startswith('--')):
        shortstep = 0
        j = 1
        while j < len(lastarg):
            curch = lastarg[j]
            if curch in get_argsopt_needargs_shortopt(args,argsopt,cmdname):
                shortstep += 1
            j += 1
        if shortstep > 1:
            # this is not the valid one ,so we should make this not ok
            return write_retfile(resfile,['[%s] add need args short opt more than one'%(lastarg),'please use -h|--help to see']),False
        if shortstep == 0:
            logging.info('start need args shortopt')
            for c in get_argsopt_needargs_shortopt(args,argsopt,cmdname):
                opta = get_argsopt_optattr(args,argsopt,c,cmdname)
                if opta is not None and not getattr(optattr,opta.optdest,False):
                    if lastarg.startswith('-'):
                        logging.info('add [%s]'%(c))
                        outputargs.append('%s'%(c))
                    else:
                        logging.info('add [-%s]'%(c))
                        outputargs.append('-%s'%(c))
        logging.info('start no args shortopt')
        for c in get_argsopt_noargs_shortopt(args,argsopt,cmdname):
            opta = get_argsopt_optattr(args,argsopt,c,cmdname)
            if opta is not None and not getattr(optattr,opta.optdest,False):
                if lastarg.startswith('-'):
                    logging.info('add [%s]'%(c))
                    outputargs.append('%s'%(c))
                else:
                    logging.info('add [-%s]'%(c))
                    outputargs.append('-%s'%(c))
    return write_retfile(resfile,outputargs),True

def basic_common_subcommand_completion(args,argsopt,resfile,cmdidx,cmdname,optattr,totalargs):
    outputargs = []
    lastarg = ''
    if cmdidx == (len(totalargs) - 1):
        if len(totalargs) > 1:
            lastarg = totalargs[-1]
        for c in get_argsopt_subcommand(args,argsopt,cmdname):
            if len(lastarg) == 0 or c.startswith(lastarg):
                outputargs.append(c)
    return write_retfile(resfile,outputargs)


def basic_common_completion(args,argsopt,resfile,cmdidx,cmdname,optattr,totalargs):
    s = ''
    curs , ok = basic_common_completion_option(args,argsopt,resfile,cmdidx,cmdname,optattr,totalargs)
    s += curs
    if not ok:
        return s
    s += basic_common_subcommand_completion(args,argsopt,resfile,cmdidx,cmdname,optattr,totalargs)
    s += basic_common_completion_withoutopt(args,argsopt,resfile,cmdidx,cmdname,optattr,totalargs)
    return s

def format_completion(args,argsopt,resfile,cmdidx,cmdname,optattr,totalargs):
    prevopt = None
    if len(totalargs) > 2:
        prevopt = totalargs[-2]
    logging.info('cmdidx [%d] len(%d)'%(cmdidx,len(totalargs)))
    if cmdidx == (len(totalargs) - 1):
        if prevopt is not None:
            if prevopt.startswith('--'):
                for prevopt in get_argsopt_needargs_longopt(args,argsopt,cmdname):
                    optfunc = get_argsopt_optfunc_longopt(args,argsopt,prevopt,cmdname)
                    if optfunc is not None:
                        return call_optfunc(optfunc,args,argsopt,resfile,cmdidx,cmdname,optattr,totalargs)
                    return basic_common_completion_opt(prevopt,args,argsopt,resfile,cmdidx,cmdname,optattr,totalargs)
            elif prevopt.startswith('-'):
                totallen = len(prevopt)
                j = 1
                while j < totallen:
                    curch = prevopt[j] 
                    if curch in get_argsopt_needargs_shortopt(args,argsopt,cmdname):
                        optfunc = get_argsopt_optfunc_shortopt(args,argsopt,curch,cmdname)
                        if optfunc is not None:
                            return call_optfunc(optfunc,args,argsopt,resfile,cmdidx,cmdname,optattr,totalargs)
                        return basic_common_completion_opt(curch,args,argsopt,resfile,cmdidx,cmdname,optattr,totalargs)
                    j += 1
        # now we should 
        return basic_common_completion(args,argsopt,resfile,cmdidx,cmdname,optattr,totalargs)
    else:
        # this is the 
        subcmds = argsopt.get_subcommands(cmdname)
        if subcmds is not None and len(subcmds) != 0:
            return write_retfile(resfile,['cmdname [%s]'%(cmdname),'please use -h|--help to see help'])
        argsattr = get_argsopt_argsattr(args,argsopt,cmdname)
        if argsattr.nargs == '*' or argsattr.nargs == '+':
            pass
        elif argsattr.nargs == '?':
            return write_retfile(resfile,['cmdname [%s] just need one args'%(cmdname),'please use -h|--help to see help'])
        else:
            argscnt = int(argsattr.nargs)
            if argscnt > (len(totalargs) - cmdidx - 1):
                return write_retfile(resfile,['cmdname [%s] more than %d'%(cmdname,argscnt),'please use -h|--help to see help'])
        return basic_common_completion_withoutopt(args,argsopt,cmdidx,cmdname,optattr,totalargs)

##############################
##  this is the code for extended ,so
##  we should make this ok
##############################
extended_opt_code=''

def __get_priority(inputprior):
    priority = None
    if len(inputprior) == 0 or (len(inputprior) == 1 and inputprior[0] == 'NONE'):
        pass
    else:
        priority = []
        for c in inputprior:
            if c == 'SUBCMD_JSON' :
                priority.append(extargsparse.SUB_COMMAND_JSON_SET)
            elif c == 'CMD_JSON' :
                priority.append(extargsparse.COMMAND_JSON_SET)
            elif c == 'ENV_SUBCMD_JSON' :
                priority.append(extargsparse.ENV_SUB_COMMAND_JSON_SET)
            elif c == 'ENV_CMD_JSON':
                priority.append(extargsparse.ENV_COMMAND_JSON_SET)
            elif c == 'ENV_CMD' :
                priority.append(extargsparse.ENVIRONMENT_SET)
            elif c == 'NONE':
                break
            else:
                raise Exception('unknown priority (%s)'%(c))
    return priority


def completion_format(args):
    s = ''
    if args.jsonstr is None:
        args.jsonstr = read_file(args.jsonfile)
    if args.optfile is not None:
        args.options = read_file(args.optfile)
    logging.info('jsonstr (%s)'%(args.jsonstr))
    extoptions = extargsparse.ExtArgsOptions(args.options)
    priority = None
    if extoptions.priority is not None:
        priority = __get_priority(extoptions.priority)
    argsopt = CompleteExtArgs(extoptions,priority)
    argsopt.load_command_line_string(args.jsonstr)
    completions = argsopt.get_completions(args.args)
    for l in completions:
        s += '%s\n'%(l)    
    return s    



def get_full_trace_back(trback,tabs=1,cnt=0):
    s = ''
    frm = getattr(trback,'tb_frame',None)
    if frm is not None:
        code = getattr(frm,'f_code',None)
        if code is not None:
            s += ' ' * tabs * 4
            s += '[%d][%s:%s:%s]\n'%(cnt,code.co_filename,code.co_name,frm.f_lineno)
            ntrace = getattr(trback,'tb_next',None)
            if ntrace is not None:
                s += get_full_trace_back(ntrace,tabs,cnt+1)
    return s

def set_log_level(args):
    loglvl= logging.ERROR
    if args.verbose >= 3:
        loglvl = logging.DEBUG
    elif args.verbose >= 2:
        loglvl = logging.INFO
    elif args.verbose >= 1 :
        loglvl = logging.WARN
    if logging.root is not None and len(logging.root.handlers) > 0:
        logging.root.handlers = []
    # we delete old handlers ,and set new handler
    logging.basicConfig(level=loglvl,format='%(asctime)s:%(filename)s:%(funcName)s:%(lineno)d\t%(message)s')
    return

def get_ver_tuple(ver):
    sarr = re.split('\.',ver)
    i = 0
    while i < len(sarr):
        sarr[i] = int(sarr[i])
        i += 1
    return sarr

def check_extargs_version(verleast):
    try:
        vernum = extargsparse.__version__
        leasttuple = get_ver_tuple(verleast)
        vertuple = get_ver_tuple(vernum)
        ok = True
        if vertuple[0] < leasttuple[0]:
            ok = False
        elif vertuple[0] == leasttuple[0]:
            if vertuple[1] < leasttuple[1]:
                ok = False
            elif vertuple[1] == leasttuple[1]:
                if vertuple[2] < leasttuple[2]:
                    ok = False              
        if not ok :
            raise Exception('version %s < %s'%(vernum,verleast))
    except:
        raise Exception('must at lease %s version of extargsparse'%(verleast))
    return


def main():
    commandline='''
    {
        "verbose|v" : "+",
        "input|i" : null,
        "reserved|R##to reserve temp file##" : false,
        "jsonparse|j##if not set ,input json string from jsonfile or stdin##" : null,
        "jsonfile|J" : null,
        "output|o" : null,
        "options|O" : null,
        "optfile|F" : null,
        "debugmode|d" : false,
        "$" : "*"
    }
    '''
    check_extargs_version('1.0.0')
    parser = extargsparse.ExtArgsParse(None,[])
    parser.load_command_line_string(commandline)
    args = parser.parse_command_line()
    set_log_level(args)
    if args.debugmode:
        s = completion_format(args)
    else:
        try:        
            s = completion_format(args)
        except:
            trback = sys.exc_info()[2]
            exceptname = sys.exc_info()[1]
            s = ''
            s += 'exception %s:\n'%(exceptname)
            s +='trace back:\n'
            s += get_full_trace_back(trback,1,0)
            sys.stderr.write('%s'%(s))
            return
    output_string(s,args.output)
    return

if __name__ == '__main__':
    main()