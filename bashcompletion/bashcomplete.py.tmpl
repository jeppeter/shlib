#! /usr/bin/env python

import os
import extargsparse
import logging
import re
import sys
import subprocess


def read_file(infile=None):
    s = ''
    fin = sys.stdin
    if infile is not None:
        fin = open(infile,'rb')
    for l in fin:
        if sys.version[0] == '2':
            s += l
        else:
            s += l.decode(encoding='UTF-8')
    if fin != sys.stdin:
        fin.close()
    fin = None
    return s

def write_retfile(file,lines):
    s = ''
    if file is not None:
        with open(file,'ab') as f:
            for l in lines:
                f.write('%s\n'%(l))
    for l in lines:
        s += '%s\n'%(l)
    return s

def output_string(s,outfile=None):
    fout = sys.stdout
    if outfile is not None:
        fout = open(outfile,'wb')
    fout.write('%s'%(s))
    if fout != sys.stdout:
        fout.close()
    fout = None
    return

def get_full_trace_back(trback,tabs=1,cnt=0):
    s = ''
    frm = getattr(trback,'tb_frame',None)
    if frm is not None:
        code = getattr(frm,'f_code',None)
        if code is not None:
            s += ' ' * tabs * 4
            s += '[%d][%s:%s:%s]\n'%(cnt,code.co_filename,code.co_name,frm.f_lineno)
            ntrace = getattr(trback,'tb_next',None)
            if ntrace is not None:
                s += get_full_trace_back(ntrace,tabs,cnt+1)
    return s


def encode_string_mode(instr,bmode):
    retstr = instr
    if sys.version[0] != '2' and bmode:
        retstr = instr.encode(encoding='UTF-8')
    return retstr

def encode_eval_string(instr):
    rets = ''
    for c in instr:
        if c == '`':
            rets += '\\`'
        elif c == '"':
            rets += '\\"'
        else:
            rets += c
    return rets

def change_shell_special_dir(d):
    retd = d
    devnullfd = None
    logging.info('d [%s]'%(d))
    try:
        #devnullfd = open(os.devnull,'w')
        p = subprocess.Popen(['/bin/bash'],stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=devnullfd,shell=False)
        bmode = False
        if 'b' in p.stdin.mode:
            bmode = True
        curdir = os.getcwd()
        # to make the current directory
        p.stdin.write(encode_string_mode('cd %s\n'%(curdir),bmode))
        cmd = 'export DIRVALUE=`%s '%(sys.executable)
        cmd += '-c "import os;import sys;print(\'%s\'%(os.path.expanduser(sys.argv[1])))"'
        cmd += ' "%s"`'%(encode_eval_string(d))
        cmd += '\n'
        logging.info('cmd [%s]'%(cmd))
        p.stdin.write(encode_string_mode(cmd,bmode))
        p.stdin.write(encode_string_mode('echo -n "$DIRVALUE"\n',bmode))
        p.stdin.close()
        p.stdin = None
        lines = p.stdout.readlines()
        p.stdout.close()
        p.stdout = None
        for l in lines:
            if sys.version[0] != '2':
                l = l.decode(encoding='UTF-8')
            l = l.rstrip('\r\n')
            retd = l
            logging.info('[%s] [%s]'%(d,retd))
        p = None
    except:
        trback = sys.exc_info()[2]
        exceptname = sys.exc_info()[1]
        s = ''
        s += 'exception %s:\n'%(exceptname)
        s +='trace back:\n'
        s += get_full_trace_back(trback,1,0)
        logging.warning('%s'%(s))
        retd = d
    finally:
        if devnullfd is not None:
            devnullfd.close()
        devnullfd = None
    return retd

class ValueAttr(object):
    def __init__(self):
        self.__obj = dict()
        self.__access = dict()
        return

    def __setattr__(self,key,val):
        if not key.startswith('_'):
            self.__obj[key] = val
            self.__access[key] = True
            return
        self.__dict__[key] = val
        return

    def __getattr__(self,key):
        if not key.startswith('_'):
            if key in self.__obj.keys():
                return self.__obj[key]
            return None
        return self.__dict__[key]

    def __str__(self):
        s = '{'
        for k in self.__obj.keys():
            s += '%s=%s;'%(k,self.__obj[k])
        s += '}'
        return s

    def __repr__(self):
        return self.__str__()

    def __has_accessed(self,name):
        if name in self.__access.keys():
            return True
        return False

    def is_accessed(self,name):
        return self.__has_accessed(name)

    def get_keys(self):
        return self.__obj.keys()


class _OptionAccess(object):
    def __init__(self):
        self.__accessed = dict()
        return

    def format_call_msg(self,msg,callstack):
        inmsg = ''  
        if callstack is not None:
            try:
                frame = sys._getframe(callstack)
                inmsg += '[%-10s:%-20s:%-5s] '%(frame.f_code.co_filename,frame.f_code.co_name,frame.f_lineno)
            except:
                inmsg = ''
        inmsg += msg
        return inmsg


    def __setattr__(self,k,v):
        if k.startswith('_'):
            self.__dict__[k]=v
            return
        msg = self.format_call_msg('set [%s]'%(k),5)
        #logging.info('%s'%(msg))
        self.__accessed[k] = True
        return

    def __getattr__(self,k,defv=None):
        if k.startswith('_'):
            if k not in self.__dict__.keys():
                return defv
            return self.__dict__[k]
        msg = self.format_call_msg('get [%s] [%s]'%(k,self.__format()),2)
        #logging.info('%s'%(msg))
        if k not in self.__accessed.keys():
            return False
        return True

    def __format(self):
        s = '['
        for k in self.__accessed.keys():
            s += '%s;'%(k)
        s += ']'
        return s

    def __str__(self):
        return self.__format()

    def __repr__(self):
        return self.__format()

class ResultAttr(object):
    def __init__(self):
        self.__objs = dict()
        return

    def __setattr__(self,k,v):
        if k.startswith('_'):
            self.__dict__[k]=v
            return
        self.__objs[k] = v
        return

    def __getattr__(self,k,defv=None):
        if k.startswith('_'):
            if k not in self.__dict__.keys():
                return defv
            return self.__dict__[k]
        if k  in self.__objs.keys():
            return self.__objs[k]
        return defv

    def __format(self):
        s = '['
        for k in self.__objs.keys():
            s += '%s=%s;'%(k,self.__objs[k])
        s += ']'
        return s

    def __str__(self):
        return self.__format()

    def __repr__(self):
        return self.__format()

class CompleteExtArgs(extargsparse.ExtArgsParse):
    def __init__(self,options=None,priority=None):
        super(CompleteExtArgs,self).__init__(options,priority)
        self.options = options
        logging.info('options [%s]'%(self.options))
        if self.options is None:
            self.options = extargsparse.ExtArgOptions()
        if self.options.longprefix is None:
            raise Exception('can not be longprefix null')
        if self.options.shortprefix is not None and self.options.shortprefix == self.options.longprefix:
            self.options.bundled = False
        else:
            self.options.bundled = True
        logging.info('bundled [%s]'%(self.options.bundled))
        if self.options.endwordshandle is None:
            self.options.endwordshandle = False
        self.priority = priority
        if priority is None:
            self.priority = [extargsparse.SUB_COMMAND_JSON_SET,extargsparse.COMMAND_JSON_SET,\
                extargsparse.ENVIRONMENT_SET,extargsparse.ENV_SUB_COMMAND_JSON_SET,\
                extargsparse.ENV_COMMAND_JSON_SET]
        self.optaccess = _OptionAccess()
        self.storevalues = ValueAttr()

        self.leftargs = []
        self.__ended = 0
        self.__curidx = 1
        self.__validx = -1
        self.__curcharidx = -1
        self.__longstep = -1
        self.__shortstep = -1

        self.__laststepopts = []
        try:
            self.__verbose = int(os.environ['BASHCOMPLETE_DEBUG'])
        except:
            self.__verbose = 0

        self.__step_functions = {
            'string' : self.__string_step,
            'unicode' : self.__string_step,
            'int' : self.__int_step,
            'long' : self.__long_step,
            'float' : self.__float_step,
            'list' : self.__list_step,
            'bool' : self.__bool_step,
            'args' : self.__args_step,
            'command' : self.__command_step,
            'prefix' : self.__prefix_step,
            'count': self.__count_step,
            'help' : self.__help_step,
            'jsonfile' : self.__jsonfile_step
        }

        self.__complete_functions = {
            'string' : self.__string_complete,
            'unicode' : self.__string_complete,
            'int' : self.__int_complete,
            'long' : self.__int_complete,
            'float' : self.__float_complete,
            'list' : self.__list_complete,
            'bool' : self.__bool_complete,
            'args' : self.__args_complete,
            'command' : self.__command_complete,
            'prefix' : self.__prefix_complete,
            'count': self.__count_complete,
            'help' : self.__help_complete,
            'jsonfile' : self.__jsonfile_complete
        }
        return

    def warn_message(self,message,callstack=1):
        if self.__verbose >= 3:
            msg = self.format_call_msg(message,(callstack + 1))
        else:
            msg = message
        sys.stderr.write('\n%s'%(msg))
        sys.stderr.flush()
        return

    def warn_override(self,keycls,firstcheck):
        accessed = getattr(self.optaccess,keycls.optdest,None)
        if accessed and firstcheck:
            warns = ''
            warns += '[%s'%(keycls.longopt)
            if keycls.shortopt is not None:
                warns += '|%s'%(keycls.shortopt)
            warns += '] will be override'
            self.warn_message(warns,3)
        return

    def set_access(self,keycls):
        setattr(self.optaccess,keycls.optdest,True)
        return

    def set_value(self,keycls,value):
        setattr(self.storevalues,keycls.optdest,value)
        return

    def count_value(self,keycls,value):
        origvalue = getattr(self.storevalues,keycls.optdest,None)
        if origvalue is None:
            origvalue = 0
        origvalue += 1
        setattr(self.storevalues,keycls.optdest,origvalue)
        return

    def append_value(self,keycls,value):
        origvalue = getattr(self.storevalues,keycls.optdest,None)
        if origvalue is None:
            origvalue = []
        origvalue.append(value)
        setattr(self.storevalues,keycls.optdest,origvalue)
        return

    def extend_value(self,keycls,value):
        origvalue = getattr(self.storevalues,keycls.optdest,None)
        if origvalue is None:
            origvalue = []
        origvalue.extend(value)
        setattr(self.storevalues,keycls.optdest,origvalue)
        return

    def __string_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls,firstcheck)
        if firstcheck:
            self.set_access(keycls)
            if validx < (len(params) - 1):
                filtername = params[validx]
                self.set_value(keycls,filtername)
        return 1

    def __int_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls,firstcheck)
        filtername = ''
        if validx < (len(params) - 1):
            filtername = params[validx]
        self.int_value_warn(filtername,firstcheck)
        if firstcheck:
            self.set_access(keycls)
            if validx < (len(params) - 1):
                filtername = params[validx]
                intvalue = 0
                try:
                    base = 10
                    if filtername.startswith('x') or \
                        filtername.startswith('X'):
                        base = 16
                        filtername = filtername[1:]

                    if filtername.startswith('0x') or \
                        filtername.startswith('0X'):
                        base = 16
                        filtername = filtername[2:]
                    intvalue = int(filtername,base)
                except:
                    pass
                self.set_value(keycls,intvalue)
        return 1

    def __long_step(self,validx,keycls,params,firstcheck):
        return self.__int_step(validx,keycls,params,firstcheck)

    def __float_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls,firstcheck)
        filtername = ''
        if validx < (len(params)-1):
            filtername = params[validx]
        self.float_value_warn(filtername,firstcheck)
        if firstcheck:
            self.set_access(keycls)
            if validx < (len(params) - 1):
                filtername = params[validx]
                floatvalue = 0.0
                try:
                    floatvalue = float(filtername)
                except:
                    pass
                self.set_value(keycls,floatvalue)
        return 1

    def __list_step(self,validx,keycls,params,firstcheck):
        if firstcheck:
            self.set_access(keycls)
            if validx < (len(params) - 1):
                self.append_value(keycls,params[validx])
        return 1

    def __bool_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls,firstcheck)
        if firstcheck:
            self.set_access(keycls)
            if keycls.value:
                self.set_value(keycls,False)
            else:
                self.set_value(keycls,True)
        return 0

    def __args_step(self,validx,keycls,params,firstcheck):
        self.leftargs.append(params[validx])
        return 1

    def __command_step(self,validx,keycls,params,firstcheck):
        return 0

    def __prefix_step(self,validx,keycls,params,firstcheck):
        return 0

    def __count_step(self,validx,keycls,params,firstcheck):
        if firstcheck:
            self.set_access(keycls)
            self.count_value(keycls,None)
        return 0

    def __jsonfile_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls,firstcheck)
        if validx < (len(params)-1):
            if os.path.isfile(params[validx]):
                warns = ''
                warns += '[%s'%(keycls.longopt)
                if keycls.shortopt is not None:
                    warns += '|%s'%(keycls.shortopt)
                warns += '] set [%s] not valid file'%(params[validx])
                self.warn_message(warns)
        if firstcheck:
            self.set_access(keycls)
        return 1

    def __help_step(self,validx,keycls,params,firstcheck):
        return -1

    def get_filter_name(self,instr,filtername='',endwords=''):
        if len(filtername) > 0 and not instr.startswith(filtername):
            return None
        if self.options.endwordshandle and len(endwords) > 0 and not instr.endswith(endwords):
            return None
        if self.options.endwordshandle and len(endwords) > 0  :
            return instr.replace('%s$'%(endwords),'')
        return instr



    def __string_complete(self,validx,keycls,params,endwords=''):
        retcompletions = []
        filtername = ''
        if len(params) > 1:
            filtername = params[-1]
        # now to add file name 
        for c in self.file_common_completion(filtername,None):
            r = self.get_filter_name(c,filtername,endwords)
            if r is not None:
                retcompletions.append(r)
        return retcompletions

    def int_value_warn(self,totalwords,warning=True):
        if len(totalwords) > 0 and warning:
            matched = False
            if 'x' in totalwords or 'X' in totalwords:
                intexpr = re.compile('^(0x|x)?([0-9a-f]*)$',re.I)
                if intexpr.match(totalwords):
                    matched = True
            else:
                intexpr = re.compile('^([0-9]*)$',re.I)
                if intexpr.match(totalwords):
                    matched = True
            if not matched:
                warns = '['
                warns +=  keycls.longopt
                if keycls.shortopt is not None:
                    warns += '|%s'%(keycls.shortopt)
                warns += '] should number used'
                self.warn_message(warns)
        return


    def __int_complete(self,validx,keycls,params,endwords=''):
        retcompletions = []
        filtername = ''        
        if len(params) > 1:
            filtername = params[-1]
        if self.options.endwordshandle:
            totalwords = filtername + endwords
        else:
            totalwords = filtername
        self.int_value_warn(totalwords,True)
        return retcompletions

    def __long_complete(self,validx,keycls,params,endwords=''):
        return self.__int_complete(validx,keycls,params,endwords)

    def float_value_warn(self,totalwords,warning=True):
        if len(totalwords) > 0 and warning:
            floatexpr = re.compile('^([\+\-])?([0-9]*)?(\.[0-9]*)?$')
            matched = False
            if floatexpr.match(totalwords):
                matched = True
            if not matched:
                warns = '['
                warns +=  keycls.longopt
                if keycls.shortopt is not None:
                    warns += '|%s'%(keycls.shortopt)
                warns += '] should float'
                self.warn_message(warns)
        return


    def __float_complete(self,validx,keycls,params,endwords=''):
        retcompletions = []
        filtername = ''
        if len(params) > 1:
            filtername = params[-1]
        if self.options.endwordshandle :
            totalwords = filtername + endwords
        else:
            totalwords = filtername
        self.float_value_warn(totalwords,True)
        return retcompletions

    def __bool_complete(self,validx,keycls,params,endwords=''):
        # nothing to handle
        return []

    def __args_complete(self,validx,keycls,params,endwords=''):
        return []

    def __command_complete(self,validx,keycls,params,endwords=''):
        return []

    def __prefix_complete(self,validx,keycls,params,endwords=''):
        return []

    def __count_complete(self,validx,keycls,params,endwords=''):
        return []

    def __help_complete(self,validx,keycls,params,endwords=''):
        return []

    def __jsonfile_complete(self,validx,keycls,params,endwords=''):
        return self.__string_complete(validx,keycls,params,endwords)

    def __list_complete(self,validx,keycls,params,endwords=''):
        return self.__string_complete(validx,keycls,params,endwords)

    def call_step_func(self,validx,keycls,params,firstcheck=True):
        if keycls.attr is not None and keycls.attr.optparse is not None:
            return self.call_func(keycls.attr.optparse,self,validx,keycls,params,firstcheck)
        return self.__step_functions[keycls.type](validx,keycls,params,firstcheck)

    def format_subcmd(self,maincmd,subcmd):
        retcmd = ''
        if maincmd is not None and len(maincmd) > 0:
            retcmd += '%s.'%(maincmd)
        retcmd += subcmd
        return retcmd

    def __get_longopts_cmd(self,curcmd=''):
        longopts = []
        cmdopts = self.get_cmdopts(curcmd)
        logging.info('[%s]cmdopts (%s)'%(curcmd,cmdopts))
        for opt in cmdopts:
            if not opt.isflag  or opt.type == 'args':
                continue
            longopts.append(opt.longopt)
        return longopts

    def __get_shortflags_cmd(self,curcmd=''):
        shortflags = []
        cmdopts = self.get_cmdopts(curcmd)
        for opt in cmdopts:
            if not opt.isflag  or opt.type == 'args':
                continue
            if opt.shortflag is not None:
                shortflags.append(opt.shortflag)
        return shortflags


    def __check_uniq(self,sarr,notice=''):
        idx = 0
        while idx < len(sarr):
            if idx >= (len(sarr)-1):
                break
            if sarr[idx] == sarr[(idx+1)]:
                del sarr[idx]
                self.info('[%s][%d] same [%s]'%(notice,idx,sarr[idx]))
                continue
            idx += 1
        return sarr


    def __get_longopts(self,cmdname=''):
        longopts = []
        sarr = []
        if cmdname is not None and len(cmdname) > 0:
            sarr = re.split('\.',cmdname)
        idx = len(sarr)
        while idx > 0:
            curcmd = '.'.join(sarr[:idx])
            logging.info('curcmd [%s]'%(curcmd))
            longopts.extend(self.__get_longopts_cmd(curcmd))
            idx -= 1
        longopts.extend(self.__get_longopts_cmd(''))
        longopts = sorted(longopts)
        return self.__check_uniq(longopts,'longopts')

    def __get_shortflags(self,cmdname=''):
        shortflags = []
        sarr = []
        if cmdname is not None and len(cmdname) > 0:
            sarr = re.split('\.',cmdname)
        idx = len(sarr)
        while idx > 0:
            curcmd = '.'.join(sarr[:idx])
            shortflags.extend(self.__get_shortflags_cmd(curcmd))
            idx -= 1
        shortflags.extend(self.__get_shortflags_cmd(''))
        shortflags = sorted(shortflags)
        return self.__check_uniq(shortflags,'shortflags')


    def __get_opt_longopt_cmd(self,longopt,cmdname=''):
        cmdopts = self.get_cmdopts(cmdname)
        for opt in cmdopts:
            if not opt.isflag or opt.type == 'args':
                continue
            if opt.longopt == longopt:
                return opt
        return None

    def __get_opt_longopt(self,longopt,cmdname):
        sarr = []
        if cmdname is not None and len(cmdname) > 0:
            sarr = re.split('\.',cmdname)
        idx = len(sarr)
        while idx > 0:
            curcmd = '.'.join(sarr[:idx])
            curopt = self.__get_opt_longopt_cmd(longopt,curcmd)
            if curopt is not None:
                return curopt
            idx -= 1
        return self.__get_opt_longopt_cmd(longopt,'')


    def __get_opt_shortflag_cmd(self,shortflag,cmdname=''):
        cmdopts = self.get_cmdopts(cmdname)
        for opt in cmdopts:
            if not opt.isflag or opt.type == 'args':
                continue
            if opt.shortflag is not None and opt.shortflag == shortflag:
                return opt
        return None

    def __get_opt_shortflag(self,shortflag,cmdname):
        sarr = []
        if cmdname is not None and len(cmdname) > 0:
            sarr = re.split('\.',cmdname)
        idx = len(sarr)
        while idx > 0:
            curcmd = '.'.join(sarr[:idx])
            curopt = self.__get_opt_shortflag_cmd(shortflag,curcmd)
            if curopt is not None:
                return curopt
            idx -= 1
        return self.__get_opt_shortflag_cmd(shortflag,'')

    def __step_longopt(self,must=False):
        need = must
        if not need and self.__longstep >= 0:
            need = True
        if need:
            assert(self.__longstep >= 0)
            assert(self.__validx > 0)
            assert(self.__shortstep < 0)
            assert(self.__curcharidx < 0)
            # we should give the validx to the next one
            self.__curidx = self.__validx
            self.__curidx += self.__longstep
            self.__validx = -1
            self.__longstep = -1
        return self.__curidx

    def __step_shortopt(self,must=True):
        need = must
        if not need and self.__shortstep >= 0:
            need = True
        if need:
            assert(self.__curcharidx >= 0)
            if self.__shortstep >= 0:
                # we maybe use some bad options , so we need any error
                self.__curidx = self.__validx
                self.__curidx += self.__shortstep
            self.__valid = -1
            self.__shortstep = -1
            self.__curcharidx = -1
        return self.__curidx

    def __get_cmd_step(self,cmdname,params):
        if self.__ended > 0:
            return cmdname,None
        oldidx = self.__step_longopt(False)
        oldcharidx = self.__curcharidx
        logging.info('[%d][%d] __laststepopts (%s)'%(oldidx,oldcharidx,self.__laststepopts))
        while True:
            if oldidx >= (len(params)-1):
                self.__ended = 1
                self.__curidx = oldidx
                self.__validx = oldidx
                self.__longstep = -1
                self.__shortstep = -1
                self.__curcharidx = -1
                logging.info(' ')
                return cmdname,None

            curopt = params[oldidx]
            if curopt == '--':
                if (oldidx + 1) < len(params):
                    self.leftargs.extend(params[(oldidx+1):])
                self.__curidx = len(params)
                self.__validx = len(params)
                assert(self.__shortstep < 0)
                assert(self.__curcharidx < 0)
                self.__ended = 1
                logging.info(' ')
                return cmdname,None
            if oldcharidx > 0:
                while oldcharidx < len(curopt):
                    curch = curopt[oldcharidx]
                    if curch in self.__get_shortflags(cmdname):
                        opt = self.__get_opt_shortflag(curch,cmdname)
                        self.__curidx = oldidx
                        # to make the next one
                        self.__curcharidx = (oldcharidx+1)
                        self.__validx = (oldidx + 1)
                        logging.info(' ')
                        return cmdname,opt
                    else:
                        self.warn('[%d][%d] [%s] not in the options'%(oldidx,oldcharidx,curch))
                    oldcharidx += 1

                if len(curopt) <= oldcharidx:
                    oldidx = self.__step_shortopt(True)
                    oldcharidx = self.__curcharidx
                    # we get the next one
                    logging.info(' ')
                    continue
            else:
                if self.options.bundled:
                    if curopt.startswith(self.options.longprefix):
                        logging.info('cmdname [%s] curopt [%s]'%(cmdname,curopt))
                        if curopt in self.__get_longopts(cmdname):
                            opt = self.__get_opt_longopt(curopt,cmdname)
                            self.__curidx = oldidx
                            self.__validx = (oldidx + 1)
                            logging.info(' ')
                            return cmdname,opt
                        else:
                            if self.options.parseall:
                                self.warn('[%d] [%s] not supported'%(oldidx,curopt))
                                self.leftargs.append(params[oldidx])
                                oldidx += 1
                                oldcharidx = -1
                                assert(self.__longstep < 0)
                                assert(self.__shortstep < 0)
                                continue
                            # that is ended
                            self.leftargs.extend(params[oldidx:])
                            self.__curidx = len(params)
                            self.__curcharidx = -1
                            self.__validx = len(params)
                            self.__ended = 1
                            assert(self.__longstep < 0)
                            assert(self.__shortstep < 0)
                            logging.info(' ')
                            return cmdname,None
                    elif self.options.shortprefix is not None and curopt.startswith(self.options.shortprefix):
                        oldcharidx = len(self.options.shortprefix)
                        while oldcharidx < len(curopt):
                            curch = curopt[oldcharidx]
                            if curch in self.__get_shortflags(cmdname):
                                opt = self.__get_opt_shortflag(curch,cmdname)
                                self.__curidx = oldidx
                                self.__curcharidx = (oldcharidx + 1 )
                                self.__validx = (oldidx + 1)
                                logging.info(' ')
                                return cmdname,opt
                            else:
                                if oldidx < (len(params) - 1):
                                    self.warn('[%d][%d] [%s] not in the options'%(oldidx,oldcharidx,curch))
                            oldcharidx += 1

                        if len(curopt) <= oldcharidx:
                            logging.info('shortstep %d'%(self.__shortstep))
                            if self.__shortstep < 0:
                                # this means that nothing in the more
                                if not self.options.parseall:
                                    self.options.extend(params[oldidx:])
                                    self.__curidx = len(params)
                                    self.__validx = len(params)
                                    assert(self.__longstep < 0)
                                    self.__curcharidx = -1
                                    self.__ended = 1
                                    logging.info(' ')
                                    return cmdname,None
                                # parse all ,so add it to the command
                                self.leftargs.append(params[oldidx])
                                oldidx += 1
                                oldcharidx = -1
                                self.__curcharidx = -1
                                continue                                
                            oldidx = self.__step_shortopt(True)
                            oldcharidx = self.__curcharidx
                            # we get the next one
                            continue
                else:
                    # not bundle ,because this is the long and short prefix
                    shortlen = len(self.options.longprefix)
                    if len(curopt) > (shortlen + 1) and curopt.startswith(self.options.longprefix):
                        logging.info('cmdname [%s]'%(cmdname))
                        if curopt in self.__get_longopts(cmdname):
                            opt = self.__get_opt_longopt(curopt,cmdname)
                            self.__curidx = oldidx
                            self.__validx = (oldidx + 1)
                            logging.info(' ')
                            return cmdname,opt
                        else:
                            if self.options.parseall:
                                if oldidx < (len(params) - 1):
                                    self.warn('[%d] [%s] not supported'%(oldidx,curopt))
                                self.leftargs.append(params[oldidx])
                                oldidx += 1
                                oldcharidx = -1
                                assert(self.__longstep < 0)
                                assert(self.__shortstep < 0)
                                continue
                            # that is ended
                            self.leftargs.extend(params[oldidx:])
                            self.__curidx = len(params)
                            self.__curcharidx = -1
                            self.__validx = len(params)
                            self.__ended = 1
                            assert(self.__longstep < 0)
                            assert(self.__shortstep < 0)
                            logging.info(' ')
                            return cmdname,None

                    if len(curopt) == (shortlen + 1):
                        curch = curopt[shortlen]
                        if curch in self.__get_shortflags(cmdname):
                            opt = self.__get_opt_shortflag(curch,cmdname)
                            self.__curidx = oldidx
                            self.__validx = (oldidx + 1)
                            # make this as the long step
                            self.__curcharidx = -1
                            assert(self.__shortstep < 0)
                            assert(self.__longstep < 0)
                            logging.info(' ')
                            return cmdname,opt
                        else:
                            if self.options.parseall:
                                if oldidx < (len(params) - 1):
                                    self.warn('[%d] [%s] not supported'%(oldidx,curopt))
                                self.leftargs.append(params[oldidx])
                                oldidx += 1
                                oldcharidx = -1
                                assert(self.__longstep < 0)
                                assert(self.__shortstep < 0)
                                continue
                            self.leftargs.extend(params[oldidx:])
                            self.__ended = 1
                            self.__curidx = len(params)
                            self.__validx = len(params)
                            self.__curcharidx = -1
                            assert(self.__shortstep < 0)
                            assert(self.__longstep < 0)
                            logging.info(' ')
                            return cmdname,None
            # that can not be handled
            subcmds = self.get_subcommands(cmdname)
            if subcmds is not None:
                if params[oldidx] in subcmds:
                    if cmdname is None:
                        cmdname = ''
                    if len(cmdname) > 0:
                        cmdname += '.'
                    cmdname += params[oldidx]
            else:
                if self.options.parseall:
                    self.leftargs.append(params[oldidx])
                else:
                    self.leftargs.extend(params[oldidx:])
                    self.__curidx = len(params)
                    self.__validx = len(params)
                    self.__curcharidx = -1
                    self.__ended = 1
                    assert(self.__shortstep < 0)
                    assert(self.__longstep < 0)
                    logging.info(' ')
                    return cmdname,None
            oldidx += 1
            oldcharidx = -1
        logging.info(' ')
        return cmdname,None

    def __step(self,step,opt):
        if self.__curcharidx >= 0:
            if self.__shortstep < 0:
                self.__shortstep = 0
            if self.__shortstep > 0:
                assert(len(self.__laststepopts) > 0)
                self.warn('[%s] with [%s] conflict'%(self.__laststepopts[-1].shortflag, opt.shortflag))
                self.__shortstep = 0
                self.__laststepopts = []
            self.__shortstep += step
            if step > 0:
                self.__laststepopts.append(opt)
                self.info('[%s] set step [%d]'%(self.__laststepopts[-1].shortflag,step))
        else:
            if self.__longstep < 0:
                self.__longstep = 0
            assert(self.__longstep == 0)
            self.__longstep += step
        return

    def step_completes(self,args=[]):
        self.optaccess = _OptionAccess()
        self.leftargs = []
        curcmd = ''
        # now we should give the 
        idx = 1
        result = ResultAttr()
        result.stopped = False
        result.lastopt = None
        result.lastidx = None
        while True:
            curcmd,opt = self.__get_cmd_step(curcmd,args)
            if opt is None:
                break
            logging.info('[%s] opt[%s] shortstep [%d]'%(curcmd,opt,self.__shortstep))
            step = self.call_step_func(self.__validx,opt,args)
            if step < 0:
                # this means we should end of this
                self.leftargs.extend(args[self.__validx:])
                self.__ended = 1
                self.__validx = len(args)
                self.__curidx = len(args)
                self.__shortstep = -1
                self.__longstep = -1
                self.__curcharidx = -1
                result.stopped = True
                break
            self.__step(step,opt)
            if step > 0:
                result.lastidx = self.__validx
                result.lastopt = opt
        self.__laststepopts = []
        result.cmdname = curcmd
        logging.info('result (%s)'%(result))
        filtername = ''
        if len(args) > 1:
            filtername = args[-1]
        if not result.stopped and self.options.shortprefix is not None and self.options.bundled:
            if filtername.startswith(self.options.shortprefix) and not filtername.startswith(self.options.longprefix):
                idx = len(self.options.shortprefix)
                while idx < len(filtername):
                    curch = filtername[idx]
                    if curch in self.__get_shortflags(result.cmdname):
                        opt = self.__get_opt_shortflag(curch,result.cmdname)
                        if opt is not None:
                            validx = len(args)
                            step = self.call_step_func(validx,opt,args,False)
                            if step < 0:
                                result.stopped = True
                                break
                    idx += 1
        return result

    def completion_call_opt(self,validx,opt,params,endwords=''):
        if opt.attr is not None and opt.attr.completefunc is not None:
            return self.call_func(opt.attr.completefunc,self,validx,opt,params,endwords)
        return self.__opt_complete_map[opt.type](validx,opt,params,endwords)

    def __get_argsattr(self,cmdname):
        cmdopts = self.get_cmdopts(cmdname)
        for opt in cmdopts:
            if opt.type == 'args':
                return opt
        return None

    def file_common_completion(self,pathpat,filterop=None):
        retfiles = []
        basedir = os.path.dirname(pathpat)
        logging.info('basedir [%s]'%(basedir))
        specialhandle = False
        if len(basedir) == 0:
            basedir = change_shell_special_dir(pathpat)
            if basedir == pathpat:
                basedir = '.'
                appenddir = ''
            else:
                appenddir = pathpat
                while len(appenddir) > 0 and appenddir[-1] == os.path.sep:
                    appenddir = appenddir[:-2]
                specialhandle = True
        else:
            appenddir = basedir
        reald = change_shell_special_dir(basedir)
        logging.debug('[%s][%s]reald [%s]'%(pathpat,basedir,reald))
        try:
            for c in os.listdir(reald):
                ok = True
                if len(appenddir) == 0:
                    ofile = c
                elif specialhandle:                    
                    ofile = '%s%c%s'%(appenddir,os.path.sep,c)
                else:
                    ofile = os.path.join(basedir,c)
                logging.debug('c [%s] ofile[%s]'%(c,ofile))
                if filterop is not None:
                    ok = filterop(ofile)
                if ok and (len(pathpat) == 0 or ofile.startswith(pathpat)):
                    retfiles.append(ofile)
        except:
            # nothing to handle 
            retfiles = []
        return retfiles


    def call_completion_cmd_nargs(self,cmdname,params,endwords=''):
        addmost = -1
        filtername = ''
        if len(params) > 1:
            filtername = params[-1]
        argsattr = self.__get_argsattr(cmdname)
        if argsattr is not None:
            if argsattr.nargs != '+' and argsattr.nargs != '*':
                if argsattr.nargs == '?':
                    addmost = 1
                else:
                    addmost = argsattr.nargs
        retcompletions = []
        if addmost >= 0 and addmost < len(self.leftargs):
            return retcompletions
        validx = len(params) - 1
        if argsattr.attr is not None and argsattr.attr.completefunc is not None:
            retcompletions.extend(self.call_func(argsattr.attr.completefunc,self,validx,argsattr,params,endwords))
            return
        curcompletions = self.file_common_completion(filtername,None)
        curcompletions = sorted(curcompletions)
        for c in curcompletions:
            curfile = self.get_filter_name(c,filtername,endwords)
            if curfile is not None:
                retcompletions.append(curfile)
        return retcompletions

    def __completion_shortflag_cmd(self,cmdname,params,stepped=False,endwords=''):
        filtername = ''
        if len(params) > 1:
            filtername = params[-1]
        validx = 1
        if len(params) > 1:
            validx = (len(params) - 1)
        curcompletions = []
        if self.options.bundled and self.options.shortprefix is not None:
            if len(filtername) == 0:
                for c in self.__get_shortflags(cmdname):
                    curc = '%s%s'%(self.options.shortprefix,c)
                    opt = self.__get_opt_shortflag(c,cmdname)
                    if opt is not None:
                        step = self.call_step_func(validx,opt,params,False)
                        if (step == 0  or not stepped) and ( not getattr(self.optaccess, opt.optdest,False)  or \
                            opt.type == 'list' ):
                            if self.options.endwordshandle and curc.endswith(endwords):
                                curcompletions.append(curc)
                            elif not self.options.endwordshandle:
                                curcompletions.append(curc)
            elif filtername.startswith(self.options.shortprefix) and not filtername.startswith(self.options.longprefix) :
                for c in self.__get_shortflags(cmdname):
                    added = True
                    opt = self.__get_opt_shortflag(c,cmdname)
                    if opt is not None:
                        step = self.call_step_func(validx,opt,params,False)
                        if (step > 0 and stepped) or (getattr(self.optaccess,opt.optdest,False) and opt.type != 'list'):
                            added = False
                    if added :
                        addc = '%s%s'%(filtername,c)
                        curcompletions.append(addc)
        elif self.options.shortprefix is not None:
            # this is not bundled ,so we do this ok
            for c in self.__get_shortflags(cmdname):
                opt = self.__get_opt_shortflag(c,cmdname)
                if opt is not None:
                    if not getattr(self.optaccess,opt.optdest,False) or opt.type == 'list':
                        curc = '%s%s'%(self.options.shortprefix,c)
                        if curc.startswith(filtername) and (not self.options.endwordshandle or len(endwords) == 0):
                            curcompletions.append(curc)
        return curcompletions

    def __completion_longopt_cmd(self,cmdname,params,endwords=''):
        filtername = ''
        if len(params) > 1:
            filtername = params[-1]
        curcompletions = []
        logging.info('cmdname [%s]'%(cmdname))
        for l in self.__get_longopts(cmdname):
            opt = self.__get_opt_longopt(l,cmdname)
            if opt is not None:
                if not getattr(self.optaccess,opt.optdest,False) or opt.type == 'list':
                    curl = self.get_filter_name(l,filtername,endwords)
                    logging.info('[%s] curl [%s]'%(l,curl))
                    if curl is not None:
                        curcompletions.append(curl)
        return curcompletions


    def completion_call_cmd(self,cmdname,params,endwords=''):
        filtername = ''
        validx = 1
        if len(params) > 1:
            filtername = params[-1]
            validx = len(params) - 1
        retcompletions = []
        hasstepped = False
        if len(filtername) > 0 and filtername.startswith(self.options.shortprefix) \
            and not filtername.startswith(self.options.longprefix) and self.options.bundled:
            idx = len(self.options.shortprefix)
            while idx < len(filtername):
                curch = filtername[idx]
                opt = self.__get_opt_shortflag(curch,cmdname)
                if opt is not None:
                    step = self.call_step_func(validx,opt,params,False)
                    if step > 0:
                        hasstepped = True
                        break
                idx += 1

        if len(endwords) > 0 and not hasstepped and \
            filtername.startswith(self.options.shortprefix) and \
            not filtername.startswith(self.options.longprefix) and self.options.bundled and \
            self.options.endwordshandle :
            idx = 0
            while idx < len(endwords):
                curch = endwords[idx]
                opt = self.__get_opt_shortflag(curch,cmdname)
                if opt is not None:
                    step = self.call_step_func(validx,opt,params,False)
                    if step > 0:
                        hasstepped = True
                        break
                idx += 1
        curcompletions = []
        curcompletions = self.__completion_longopt_cmd(cmdname,params,endwords)
        curcompletions = sorted(curcompletions)
        retcompletions.extend(curcompletions)
        curcompletions = []
        curcompletions = self.__completion_shortflag_cmd(cmdname,params,hasstepped,endwords)
        curcompletions = sorted(curcompletions)
        retcompletions.extend(curcompletions)
        subcmds = self.get_subcommands(cmdname)
        curcompletions = []
        if subcmds is not None:
            for c in subcmds:
                curcmd = self.get_filter_name(c,filtername,endwords)
                if curcmd is not None:
                    curcompletions.append(curcmd)
        curcompletions = sorted(curcompletions)
        retcompletions.extend(curcompletions)
        curcompletions = self.call_completion_cmd_nargs(cmdname,params,endwords)
        curcompletions = sorted(curcompletions)
        retcompletions.extend(curcompletions)
        return retcompletions

    def completeion_call(self,validx,opt,params,endwords=''):
        retcompletions = []
        if opt.attr is not None and opt.attr.completefunc is not None:
            optcomplete = self.call_func(opt.attr.completefunc,self,validx,opt,params,endwords)
        else:
            optcomplete = self.__complete_functions[opt.type](validx,opt,params,endwords)
        retcompletions.extend(optcomplete)
        return retcompletions


    def __get_completions_cmdname(self,result,params,endwords=''):
        needopt = None
        if result.lastopt is not None and (result.lastidx < (len(params) - 1)):
            step = self.call_step_func(result.lastidx,result.lastopt,params,False)
            if   (result.lastidx + step) >= len(params):
                # this means that we have not handled all the needed
                needopt = result.lastopt
        if needopt is not None:
            # it means that we need to handle specified handle
            return self.completeion_call(result.lastidx,result.lastopt,params,endwords)
        return self.completion_call_cmd(result.cmdname,params,endwords)


    def get_completions(self,args=[],endwords=''):
        self.leftargs = []
        result = self.step_completes(args)
        logging.info('leftargs (%s)'%(self.leftargs))
        completions = []
        if result.stopped:
            return completions
        completions = self.__get_completions_cmdname(result,args,endwords='')
        return completions


                

##############################
##  this is the code for extended ,so
##  we should make this ok
##############################
extended_opt_code=''

def __get_priority(inputprior):
    priority = None
    if len(inputprior) == 0 or (len(inputprior) == 1 and inputprior[0] == 'NONE'):
        pass
    else:
        priority = []
        for c in inputprior:
            if c == 'SUBCMD_JSON' :
                priority.append(extargsparse.SUB_COMMAND_JSON_SET)
            elif c == 'CMD_JSON' :
                priority.append(extargsparse.COMMAND_JSON_SET)
            elif c == 'ENV_SUBCMD_JSON' :
                priority.append(extargsparse.ENV_SUB_COMMAND_JSON_SET)
            elif c == 'ENV_CMD_JSON':
                priority.append(extargsparse.ENV_COMMAND_JSON_SET)
            elif c == 'ENV_CMD' :
                priority.append(extargsparse.ENVIRONMENT_SET)
            elif c == 'NONE':
                break
            else:
                raise Exception('unknown priority (%s)'%(c))
    return priority

def unquote_string(qs,startqs=''):
    rets = ''
    idx = 0
    matchqs = startqs
    backslashed = 0
    while idx < len(qs):
        if idx == 0 and (qs[idx] == '\'' or qs[idx]=='"') and \
            matchqs == '':
            matchqs = qs[idx]
            idx += 1
            continue
        elif matchqs != '' and (qs[idx] == matchqs) and backslashed == 0:
            matchqs = ''
            break
        if backslashed != 0 and matchqs == '"':
            if qs[idx] == '\\':
                rets += '\\'
            elif qs[idx] == 't':
                rets += '\t'
            elif qs[idx] == 'n':
                rets += '\n'
            elif qs[idx] == '\'':
                rets += '\''
            elif qs[idx] == '"':
                rets += '"'
            else:
                logging.info('unknown \%s'%(qs[idx]))
                rets += qs[idx]
            backslashed = 0
        elif backslashed != 0 and matchqs == '\'':
            if qs[idx] == '\\':
                rets += '\\\\'
            elif qs[idx] == 't':
                rets += '\\t'
            elif qs[idx] == 'n':
                rets += '\\n'
            elif qs[idx] == '\'':
                rets += '\''
            elif qs[idx] == '"':
                rets += '\\"'
            else:
                logging.info('unknown \%s'%(qs[idx]))
                rets += qs[idx]
            backslashed = 0         
        elif qs[idx] == '\\':
            backslashed = 1
        else:
            rets += qs[idx]
        idx += 1
    return rets,matchqs


def get_handle_args(line,index,sarr):
    retsarr = []
    endwords = ''
    idx= 0
    retidx = 0
    retcnt = 0
    ended = True
    while idx < index and retidx < len(sarr):
        retcnt = 0
        while retcnt < len(sarr[retidx]) and idx < index:
            if sarr[retidx][retcnt] == line[idx]:
                idx += 1
                retcnt += 1
                continue
            if line[idx] != ' ' and \
                line[idx] != '\t':
                logging.info('[%d] [%s]'%(idx,line[idx]))
            idx += 1
        if retcnt < len(sarr[retidx]):
            retsarr.append(sarr[retidx][:retcnt])
            endwords = sarr[retidx][retcnt:]
            retsarr[retidx],startqs = unquote_string(retsarr[retidx])
            endwords,endqs = unquote_string(endwords,startqs)
            if startqs == '':
                ended = True
            else:
                ended = False
            break
        retsarr.append(sarr[retidx])
        retsarr[retidx],startqs = unquote_string(retsarr[retidx])
        idx += 1
        retidx += 1
    if ended and idx >= 1 and idx <= len(line) and (line[idx - 1] == ' ' or line[idx - 1] == '\t'):
        retsarr.append('')
    return retsarr,endwords



def completion_format(args):
    s = ''
    if args.jsonstr is None:
        args.jsonstr = read_file(args.jsonfile)
    if args.optfile is not None:
        args.options = read_file(args.optfile)
    logging.info('jsonstr (%s) options (%s)'%(args.jsonstr,args.options))
    extoptions = extargsparse.ExtArgsOptions(args.options)
    priority = None
    if extoptions.priority is not None:
        priority = __get_priority(extoptions.priority)
    argsopt = CompleteExtArgs(extoptions,priority)
    argsopt.load_command_line_string(args.jsonstr)
    retsarr,endwords = get_handle_args(args.line,args.index,args.subnargs)
    logging.debug('line [%s][%d] index [%d] retsarr (%s) endwords[%s]'%(args.line,len(args.line),args.index,retsarr,endwords))
    completions = argsopt.get_completions(retsarr,endwords)
    logging.debug('completions (%s)'%(completions))
    for l in completions:
        s += '%s\n'%(l)
    return s    




def get_full_trace_back(trback,tabs=1,cnt=0):
    s = ''
    frm = getattr(trback,'tb_frame',None)
    if frm is not None:
        code = getattr(frm,'f_code',None)
        if code is not None:
            s += ' ' * tabs * 4
            s += '[%d][%s:%s:%s]\n'%(cnt,code.co_filename,code.co_name,frm.f_lineno)
            ntrace = getattr(trback,'tb_next',None)
            if ntrace is not None:
                s += get_full_trace_back(ntrace,tabs,cnt+1)
    return s

def set_log_level(args):
    loglvl= logging.ERROR
    if args.verbose >= 3:
        loglvl = logging.DEBUG
    elif args.verbose >= 2:
        loglvl = logging.INFO
    elif args.verbose >= 1 :
        loglvl = logging.WARN
    if logging.root is not None and len(logging.root.handlers) > 0:
        logging.root.handlers = []
    # we delete old handlers ,and set new handler
    os.environ['BASHCOMPLETE_DEBUG'] = '%d'%(args.verbose)
    logging.basicConfig(level=loglvl,format='%(asctime)s:%(filename)s:%(funcName)s:%(lineno)d\t%(message)s')
    return

def get_ver_tuple(ver):
    sarr = re.split('\.',ver)
    i = 0
    while i < len(sarr):
        sarr[i] = int(sarr[i])
        i += 1
    return sarr

def check_extargs_version(verleast):
    try:
        vernum = extargsparse.__version__
        leasttuple = get_ver_tuple(verleast)
        vertuple = get_ver_tuple(vernum)
        ok = True
        if vertuple[0] < leasttuple[0]:
            ok = False
        elif vertuple[0] == leasttuple[0]:
            if vertuple[1] < leasttuple[1]:
                ok = False
            elif vertuple[1] == leasttuple[1]:
                if vertuple[2] < leasttuple[2]:
                    ok = False              
        if not ok :
            raise Exception('version %s < %s'%(vernum,verleast))
    except:
        raise Exception('must at lease %s version of extargsparse'%(verleast))
    return

def complete_handler(args,parser):
    set_log_level(args)
    if args.debugmode:
        s = completion_format(args)
    else:
        try:        
            s = completion_format(args)
        except:
            trback = sys.exc_info()[2]
            exceptname = sys.exc_info()[1]
            s = ''
            s += 'exception %s:\n'%(exceptname)
            s +='trace back:\n'
            s += get_full_trace_back(trback,1,0)
            sys.stderr.write('%s'%(s))
            return
    output_string(s,args.output)
    sys.exit(0)
    return

def main():
    commandline='''
    {
        "verbose|v" : "+",
        "input|i" : null,
        "reserved|R##to reserve temp file##" : false,
        "jsonparse|j##if not set ,input json string from jsonfile or stdin##" : null,
        "jsonfile|J" : null,
        "output|o" : null,
        "options|O" : null,
        "optfile|F" : null,
        "debugmode|d" : false,
        "line|L" : null,
        "index|I" : -1,
        "complete<complete_handler>" : {
            "$" : "*"
        }
    }
    '''
    check_extargs_version('1.0.0')
    parser = extargsparse.ExtArgsParse(None,[])
    parser.load_command_line_string(commandline)
    args = parser.parse_command_line()
    sys.stderr.write('can not get subcommand %s'%(args.subcommand))
    return

if __name__ == '__main__':
    main()