#! /usr/bin/env python

import os
import extargsparse
import logging
import re
import sys


def read_file(infile=None):
    s = ''
    fin = sys.stdin
    if infile is not None:
        fin = open(infile,'rb')
    for l in fin:
        if sys.version[0] == '2':
            s += l
        else:
            s += l.decode(encoding='UTF-8')
    if fin != sys.stdin:
        fin.close()
    fin = None
    return s

def write_retfile(file,lines):
    s = ''
    if file is not None:
        with open(file,'ab') as f:
            for l in lines:
                f.write('%s\n'%(l))
    for l in lines:
        s += '%s\n'%(l)
    return s

def output_string(s,outfile=None):
    fout = sys.stdout
    if outfile is not None:
        fout = open(outfile,'wb')
    fout.write('%s'%(s))
    if fout != sys.stdout:
        fout.close()
    fout = None
    return

class _OptionAccess(object):
    def __init__(self):
        self.__accessed = dict()
        return

    def __setattr__(self,k,v):
        if k.startswith('_'):
            self.__dict__[k]=v
            return
        self.__accessed[k] = True
        return

    def __getattr__(self,k,defv=None):
        if k.startswith('_'):
            if k not in self.__dict__.keys():
                return defv
            return self.__dict__[k]
        if k not in self.__accessed.keys():
            return False
        return True

    def __format(self):
        s = '['
        for k in self.__accessed.keys():
            s += '%s;'%(k)
        s += ']'
        return s

    def __str__(self):
        return self.__format()

    def __repr__(self):
        return self.__format()

class ResultAttr(object):
    def __init__(self):
        self.__objs = dict()
        return

    def __setattr__(self,k,v):
        if k.startswith('_'):
            self.__dict__[k]=v
            return
        self.__objs[k] = v
        return

    def __getattr__(self,k,defv=None):
        if k.startswith('_'):
            if k not in self.__dict__.keys():
                return defv
            return self.__dict__[k]
        if k  in self.__objs.keys():
            return self.__objs[k]
        return defv

    def __format(self):
        s = '['
        for k in self.__objs.keys():
            s += '%s=%s;'%(k,self.__objs[k])
        s += ']'
        return s

    def __str__(self):
        return self.__format()

    def __repr__(self):
        return self.__format()

class CompleteExtArgs(extargsparse.ExtArgsParse):
    def __init__(self,options=None,priority=None):
        super(CompleteExtArgs,self).__init__(options,priority)
        self.options = options
        if self.options is None:
            self.options = extargsparse.ExtArgOptions()
        if self.options.longprefix is None:
            raise Exception('can not be longprefix null')
        if self.options.shortprefix is not None and self.options.shortprefix == self.options.longprefix:
            self.options.bundled = False
        else:
            self.options.bundled = True
        if self.options.endwordshandle is None:
            self.options.endwordshandle = False
        self.priority = priority
        if priority is None:
            self.priority = [extargsparse.SUB_COMMAND_JSON_SET,extargsparse.COMMAND_JSON_SET,\
                extargsparse.ENVIRONMENT_SET,extargsparse.ENV_SUB_COMMAND_JSON_SET,\
                extargsparse.ENV_COMMAND_JSON_SET]
        self.optaccess = _OptionAccess()

        self.leftargs = []
        self.__ended = 0
        self.__curidx = 1
        self.__validx = -1
        self.__curcharidx = -1
        self.__longstep = -1
        self.__shortstep = -1

        self.__laststepopts = []

        self.__step_functions = {
            'string' : self.__string_step,
            'unicode' : self.__string_step,
            'int' : self.__int_step,
            'long' : self.__long_step,
            'float' : self.__float_step,
            'list' : self.__list_step,
            'bool' : self.__bool_step,
            'args' : self.__args_step,
            'command' : self.__command_step,
            'prefix' : self.__prefix_step,
            'count': self.__count_step,
            'help' : self.__help_step,
            'jsonfile' : self.__jsonfile_step
        }

        self.__complete_functions = {
            'string' : self.__string_complete,
            'unicode' : self.__string_complete,
            'int' : self.__int_complete,
            'long' : self.__int_complete,
            'float' : self.__float_complete,
            'list' : self.__list_complete,
            'bool' : self.__bool_complete,
            'args' : self.__args_complete,
            'command' : self.__command_complete,
            'prefix' : self.__prefix_complete,
            'count': self.__count_complete,
            'help' : self.__help_complete,
            'jsonfile' : self.__jsonfile_complete
        }
        return

    def warn_message(self,message,callstack=1):
        sys.stderr.write('\n%s'%(message))
        sys.stderr.flush()
        return

    def warn_override(self,keycls,firstcheck):
        accessed = getattr(self.optaccess,keycls.optdest,None)
        if accessed is not None and firstcheck:
            warns = ''
            warns += '[%s'%(keycls.longopt)
            if keycls.shortopt is not None:
                warns += '|%s'%(keycls.shortopt)
            warns += '] will be override'
            self.warn_message(warns)
        return

    def set_access(self,keycls):
        setattr(self.optaccess,keycls.optdest,True)
        return

    def __string_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls)
        if firstcheck:
            self.set_access(keycls)
        return 1        

    def __int_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls)
        filtername = ''
        if validx < (len(params) - 1):
            filtername = params[validx]
        self.int_value_warn(filtername,firstcheck)
        if firstcheck:
            self.set_access(keycls)
        return 1

    def __long_step(self,validx,keycls,params,firstcheck):
        return self.__int_step(validx,keycls,params,firstcheck)

    def __float_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls,firstcheck)
        filtername = ''
        if validx < (len(params)-1):
            filtername = params[validx]
        self.float_value_warn(filtername,firstcheck)
        if firstcheck:
            self.set_access(keycls)
        return 1

    def __list_step(self,validx,keycls,params,firstcheck):
        if firstcheck:
            self.set_access(keycls)
        return 1

    def __bool_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls,firstcheck)
        if firstcheck:
            self.set_access(keycls)
        return 0

    def __args_step(self,validx,keycls,params,firstcheck):
        self.leftargs.append(params[validx])
        return 1

    def __command_step(self,validx,keycls,params,firstcheck):
        return 0

    def __prefix_step(self,validx,keycls,params,firstcheck):
        return 0

    def __count_step(self,validx,keycls,params,firstcheck):
        if firstcheck:
            self.set_access(keycls)
        return 0

    def __jsonfile_step(self,validx,keycls,params,firstcheck):
        self.warn_override(keycls,firstcheck)
        if validx < (len(params)-1):
            if os.path.isfile(params[validx]):
                warns = ''
                warns += '[%s'%(keycls.longopt)
                if keycls.shortopt is not None:
                    warns += '|%s'%(keycls.shortopt)
                warns += '] set [%s] not valid file'%(params[validx])
                self.warn_message(warns)
        if firstcheck:
            self.set_access(keycls)
        return 1

    def __help_step(self,validx,keycls,params,firstcheck):
        return -1

    def get_filter_name(self,instr,filtername='',endwords=''):
        if len(filtername) > 0 and not instr.startswith(filtername):
            return None
        if self.options.endwordshandle and len(endwords) > 0 and not instr.endswith(endwords):
            return None
        if self.options.endwordshandle and len(endwords) > 0  :
            return instr.replace('%s$'%(endwords),'')
        return instr



    def __string_complete(self,validx,keycls,params,endwords=''):
        retcompletions = []
        filtername = ''
        if len(params) > 1:
            filtername = params[-1]
        # now to add file name 
        for c in self.file_common_completion(filtername,None):
            r = self.get_filter_name(c,filtername,endwords)
            if r is not None:
                retcompletions.append(r)
        return retcompletions

    def int_value_warn(self,totalwords,warning=True):
        if len(totalwords) > 0 and warning:
            matched = False
            if 'x' in totalwords or 'X' in totalwords:
                intexpr = re.compile('^(0x|x)?([0-9a-f]*)$',re.I)
                if intexpr.match(totalwords):
                    matched = True
            else:
                intexpr = re.compile('^([0-9]*)$',re.I)
                if intexpr.match(totalwords):
                    matched = True
            if not matched:
                warns = '['
                warns +=  keycls.longopt
                if keycls.shortopt is not None:
                    warns += '|%s'%(keycls.shortopt)
                warns += '] should number used'
                self.warn_message(warns)
        return


    def __int_complete(self,validx,keycls,params,endwords=''):
        retcompletions = []
        filtername = ''        
        if len(params) > 0:
            filtername = params[-1]
        if self.options.endwordshandle:
            totalwords = filtername + endwords
        else:
            totalwords = filtername
        self.int_value_warn(totalwords,True)
        return retcompletions

    def __long_complete(self,validx,keycls,params,endwords=''):
        return self.__int_complete(validx,keycls,params,endwords)

    def float_value_warn(self,totalwords,warning=True):
        if len(totalwords) > 0 and warning:
            floatexpr = re.compile('^([\+\-])?([0-9]*)?(\.[0-9]*)?$')
            matched = False
            if floatexpr.match(totalwords):
                matched = True
            if not matched:
                warns = '['
                warns +=  keycls.longopt
                if keycls.shortopt is not None:
                    warns += '|%s'%(keycls.shortopt)
                warns += '] should float'
                self.warn_message(warns)
        return


    def __float_complete(self,validx,keycls,params,endwords=''):
        retcompletions = []
        filtername = ''
        if len(params) > 1:
            filtername = params[-1]
        if self.options.endwordshandle :
            totalwords = filtername + endwords
        else:
            totalwords = filtername
        self.float_value_warn(totalwords,True)
        return retcompletions

    def __list_complete(self,validx,keycls,params,endwords=''):
        return self.__string_complete(validx,keycls,params,endwords)

    def call_step_func(self,validx,keycls,params,firstcheck=True):
        if keycls.attr is not None and keycls.attr.optparse is not None:
            return self.call_func(keycls.attr.optparse,self,validx,keycls,params,firstcheck)
        return self.__step_functions[keycls.type](validx,keycls,params,firstcheck)

    def format_subcmd(self,maincmd,subcmd):
        retcmd = ''
        if maincmd is not None and len(maincmd) > 0:
            retcmd += '%s.'%(maincmd)
        retcmd += subcmd
        return retcmd

    def __get_longopts_cmd(self,curcmd=''):
        longopts = []
        cmdopts = self.get_cmdopts(curcmd)
        for opt in cmdopts:
            if not opt.isflag  or opt.type == 'args':
                continue
            longopts.append(opt.longopt)
        return longopts

    def __get_shortflags_cmd(self,curcmd=''):
        shortflags = []
        cmdopts = self.get_cmdopts(curcmd)
        for opt in cmdopts:
            if not opt.isflag  or opt.type == 'args':
                continue
            if opt.shortflag is not None:
                shortflags.append(opt.shortflag)
        return shortflags


    def __check_uniq(self,sarr,notice=''):
        idx = 0
        while idx < len(sarr):
            if idx >= (len(sarr)-1):
                break
            if sarr[idx] == sarr[(idx+1)]:
                del sarr[idx]
                self.warn('[%s][%d] same'%(notice,idx))
                continue
            idx += 1
        return sarr


    def __get_longopts(self,cmdname=''):
        longopts = []
        sarr = []
        if cmdname is not None and len(cmdname) > 0:
            sarr = re.split('\.',cmdname)
        idx = len(sarr)
        while idx > 0:
            curcmd = '.'.join(sarr[:idx])
            longopts.extend(self.__get_longopts_cmd(curcmd))
            idx -= 1
        longopts.extend(self.__get_longopts_cmd(''))
        longopts = sorted(longopts)
        return self.__check_uniq(longopts,'longopts')

    def __get_shortflags(self,cmdname=''):
        shortflags = []
        sarr = []
        if cmdname is not None and len(cmdname) > 0:
            sarr = re.split('\.',cmdname)
        idx = len(sarr)
        while idx > 0:
            curcmd = '.'.join(sarr[:idx])
            shortflags.extend(self.__get_shortflags_cmd(curcmd))
            idx -= 1
        shortflags.extend(self.__get_shortflags_cmd(''))
        shortflags = sorted(shortflags)
        return self.__check_uniq(shortflags,'shortflags')


    def __get_opt_longopt_cmd(self,longopt,cmdname=''):
        cmdopts = self.get_cmdopts(cmdname)
        for opt in cmdopts:
            if not opt.isflag or opt.type == 'args':
                continue
            if opt.longopt == longopt:
                return opt
        return None

    def __get_opt_longopt(self,longopt,cmdname):
        sarr = []
        if cmdname is not None and len(cmdname) > 0:
            sarr = re.split('\.',cmdname)
        idx = len(sarr)
        while idx > 0:
            curcmd = '.'.join(sarr[:idx])
            curopt = self.__get_opt_longopt_cmd(longopt,curcmd)
            if curopt is not None:
                return curopt
            idx -= 1
        return self.__get_opt_longopt_cmd(longopt,'')


    def __get_opt_shortflag_cmd(self,shortflag,cmdname=''):
        cmdopts = self.get_cmdopts(cmdname)
        for opt in cmdopts:
            if not opt.isflag or opt.type == 'args':
                continue
            if opt.shortflag is not None and opt.shortflag == shortflag:
                return opt
        return None

    def __get_opt_shortflag(self,shortflag,cmdname):
        sarr = []
        if cmdname is not None and len(cmdname) > 0:
            sarr = re.split('\.',cmdname)
        idx = len(sarr)
        while idx > 0:
            curcmd = '.'.join(sarr[:idx])
            curopt = self.__get_opt_shortflag_cmd(shortflag,curcmd)
            if curopt is not None:
                return curopt
            idx -= 1
        return self.__get_opt_shortflag_cmd(shortflag,'')

    def __step_longopt(self,must=False):
        need = must
        if not need and self.__longstep >= 0:
            need = True
        if need:
            assert(self.__longstep >= 0)
            assert(self.__validx > 0)
            assert(self.__shortstep < 0)
            assert(self.__curcharidx < 0)
            self.__curidx += self.__longstep
            self.__validx = -1
            self.__longstep = -1
        return self.__curidx

    def __step_shortopt(self,must=True):
        need = must
        if not need and self.__shortstep >= 0:
            need = True
        if need:
            assert(self.__curcharidx >= 0)
            if self.__shortstep >= 0:
                # we maybe use some bad options , so we need any error
                self.__curidx += self.__shortstep
            self.__valid = -1
            self.__shortstep = -1
            self.__curcharidx = -1
        return self.__curidx

    def __get_cmd_step(self,cmdname,params):
        if self.__ended > 0:
            return cmdname,None
        oldidx = self.__step_longopt(False)
        oldcharidx = self.__curcharidx
        while True:
            if oldidx >= (len(params)-1):
                self.__ended = 1
                self.__curidx = oldidx
                self.__validx = oldidx
                self.__longstep = -1
                self.__shortstep = -1
                self.__curcharidx = -1
                return cmdname,None

            curopt = params[oldidx]
            if curopt == '--':
                if (oldidx + 1) < len(params):
                    self.leftargs.extend(params[(oldidx+1):])
                self.__curidx = len(params)
                self.__validx = len(params)
                assert(self.__shortstep < 0)
                assert(self.__curcharidx < 0)
                self.__ended = 1
                return cmdname,None
            if oldcharidx > 0:
                while oldcharidx < len(curopt):
                    curch = curopt[oldcharidx]
                    if curch in self.__get_shortflags(curch,cmdname):
                        opt = self.__get_opt_shortflag(curch,cmdname)
                        self.__curidx = oldidx
                        self.__curcharidx = oldcharidx
                        self.__validx = (oldidx + 1)
                        return cmdname,opt
                    else:
                        self.warn('[%d][%d] [%s] not in the options'%(oldidx,oldcharidx,curch))
                    oldcharidx += 1

                if len(curopt) <= oldcharidx:
                    oldidx = self.__step_shortopt(True)
                    oldcharidx = self.__curcharidx
                    # we get the next one
                    continue
            else:
                if self.options.bundled:
                    if curopt.startswith(self.options.longprefix):
                        if curopt in self.__get_longopts(cmdname):
                            opt = self.__get_opt_longopt(curopt,cmdname)
                            self.__curidx = oldidx
                            self.__validx = (oldidx + 1)
                            return cmdname,opt
                        else:
                            if self.options.parseall:
                                self.warn('[%d] [%s] not supported'%(oldidx,curopt))
                                self.leftargs.append(params[oldidx])
                                oldidx += 1
                                oldcharidx = -1
                                assert(self.__longstep < 0)
                                assert(self.__shortstep < 0)
                                continue
                            # that is ended
                            self.leftargs.extend(params[oldidx:])
                            self.__curidx = len(params)
                            self.__curcharidx = -1
                            self.__validx = len(params)
                            self.__ended = 1
                            assert(self.__longstep < 0)
                            assert(self.__shortstep < 0)
                            return cmdname,None
                    elif self.options.shortprefix is not None and curopt.startswith(self.options.shortprefix):
                        oldcharidx = len(self.options.shortprefix)
                        while oldcharidx < len(curopt):
                            curch = curopt[oldcharidx]
                            if curch in self.__get_shortflags(cmdname):
                                opt = self.__get_opt_shortflag(curch,cmdname)
                                self.__curidx = oldidx
                                self.__curcharidx = oldcharidx
                                self.__validx = (oldidx + 1)
                                return cmdname,opt
                            else:
                                if oldidx < (len(params) - 1):
                                    self.warn('[%d][%d] [%s] not in the options'%(oldidx,oldcharidx,curch))
                            oldcharidx += 1

                        if len(curopt) <= oldcharidx:
                            logging.info('shortstep %d'%(self.__shortstep))
                            if self.__shortstep < 0:
                                # this means that nothing in the more
                                if not self.options.parseall:
                                    self.options.extend(params[oldidx:])
                                    self.__curidx = len(params)
                                    self.__validx = len(params)
                                    assert(self.__longstep < 0)
                                    self.__curcharidx = -1
                                    self.__ended = 1
                                    return cmdname,None
                                # parse all ,so add it to the command
                                self.leftargs.append(params[oldidx])
                                oldidx += 1
                                oldcharidx = -1
                                self.__curcharidx = -1
                                continue                                
                            oldidx = self.__step_shortopt(True)
                            oldcharidx = self.__curcharidx
                            # we get the next one
                            continue
                else:
                    # not bundle ,because this is the long and short prefix
                    shortlen = len(self.options.longprefix)
                    if len(curopt) > (shortlen + 1) and curopt.startswith(self.options.longprefix):
                        if curopt in self.__get_longopts(cmdname):
                            opt = self.__get_opt_longopt(curopt,cmdname)
                            self.__curidx = oldidx
                            self.__validx = (oldidx + 1)
                            return cmdname,opt
                        else:
                            if self.options.parseall:
                                if oldidx < (len(params) - 1):
                                    self.warn('[%d] [%s] not supported'%(oldidx,curopt))
                                self.leftargs.append(params[oldidx])
                                oldidx += 1
                                oldcharidx = -1
                                assert(self.__longstep < 0)
                                assert(self.__shortstep < 0)
                                continue
                            # that is ended
                            self.leftargs.extend(params[oldidx:])
                            self.__curidx = len(params)
                            self.__curcharidx = -1
                            self.__validx = len(params)
                            self.__ended = 1
                            assert(self.__longstep < 0)
                            assert(self.__shortstep < 0)
                            return cmdname,None

                    if len(curopt) == (shortlen + 1):
                        curch = curopt[shortlen]
                        if curch in self.__get_shortflags(cmdname):
                            opt = self.__get_opt_shortflag(curch,cmdname)
                            self.__curidx = oldidx
                            self.__validx = (oldidx + 1)
                            # make this as the long step
                            self.__curcharidx = -1
                            assert(self.__shortstep < 0)
                            assert(self.__longstep < 0)
                            return cmdname,opt
                        else:
                            if self.options.parseall:
                                if oldidx < (len(params) - 1):
                                    self.warn('[%d] [%s] not supported'%(oldidx,curopt))
                                self.leftargs.append(params[oldidx])
                                oldidx += 1
                                oldcharidx = -1
                                assert(self.__longstep < 0)
                                assert(self.__shortstep < 0)
                                continue
                            self.leftargs.extend(params[oldidx:])
                            self.__ended = 1
                            self.__curidx = len(params)
                            self.__validx = len(params)
                            self.__curcharidx = -1
                            assert(self.__shortstep < 0)
                            assert(self.__longstep < 0)
                            return cmdname,None
            # that can not be handled
            subcmds = self.get_subcommands(cmdname)
            if subcmds is not None:
                if params[oldidx] in subcmds:
                    if cmdname is None:
                        cmdname = ''
                    if len(cmdname) > 0:
                        cmdname += '.'
                    cmdname += params[oldidx]
            else:
                if self.options.parseall:
                    self.leftargs.append(params[oldidx])
                else:
                    self.leftargs.extend(params[oldidx:])
                    self.__curidx = len(params)
                    self.__validx = len(params)
                    self.__curcharidx = -1
                    self.__ended = 1
                    assert(self.__shortstep < 0)
                    assert(self.__longstep < 0)
                    return cmdname,None
            oldidx += 1
            oldcharidx = -1
        return cmdname,None

    def __step(self,step,opt):
        if self.__curcharidx >= 0:
            if self.__shortstep < 0:
                self.__shortstep = 0
            if self.__shortstep > 0:
                assert(len(self.__laststepopts) > 0)
                self.warn('[%s] with [%s] conflict'%(self.__laststepopts[-1].shortflag, opt.shortflag))
                self.__shortstep = 0
                self.__laststepopts = []
            self.__shortstep += step
            if step > 0:
                self.__laststepopts.append(opt)
        else:
            if self.__longstep < 0:
                self.__longstep = 0
            assert(self.__longstep == 0)
            self.__longstep += step
        return

    def step_completes(self,args=[]):
        self.optaccess = _OptionAccess()
        self.leftargs = []
        curcmd = ''
        # now we should give the 
        idx = 1
        result = ResultAttr()
        result.stopped = False
        result.lastopt = None
        result.lastidx = None
        while True:
            curcmd,opt = self.__get_cmd_step(curcmd,args)
            if opt is None:
                break
            step = self.call_step_func(self.__validx,opt,args)
            if step < 0:
                # this means we should end of this
                self.leftargs.extend(args[self.__validx:])
                self.__ended = 1
                self.__validx = len(args)
                self.__curidx = len(args)
                self.__shortstep = -1
                self.__longstep = -1
                self.__curcharidx = -1
                result.stopped = True
                break
            self.__step(step,opt)
            if step > 0:
                result.lastidx = self.__validx
                result.lastopt = opt
        self.__laststepopts = []
        result.cmdname = curcmd
        logging.info('result (%s)'%(result))
        filtername = ''
        if len(args) > 1:
            filtername = args[-1]
        if not result.stopped and self.options.shortprefix is not None and self.options.bundled:
            if filtername.startswith(self.options.shortprefix) and not filtername.startswith(self.options.longprefix):
                idx = len(self.options.shortprefix)
                while idx < len(filtername):
                    curch = filtername[idx]
                    if curch in self.__get_shortflags(result.cmdname):
                        opt = self.__get_opt_shortflag(curch,result.cmdname)
                        if opt is not None:
                            validx = len(args)
                            step = self.call_step_func(validx,opt,args)
                            if step < 0:
                                result.stopped = True
                                break
                    idx += 1
        return result

    def completion_call_opt(self,validx,opt,params,endwords=''):
        if opt.attr is not None and opt.attr.completefunc is not None:
            return self.call_func(opt.attr.completefunc,self,validx,opt,params,endwords)
        return self.__opt_complete_map[opt.type](validx,opt,params,endwords)

    def __get_argsattr(self,cmdname):
        cmdopts = self.get_cmdopts(cmdname)
        for opt in cmdopts:
            if opt.type == 'args':
                return opt
        return None

    def file_common_completion(self,pathpat,filterop=None):
        retfiles = []
        basedir = os.path.dirname(pathpat)
        if len(basedir) == 0:
            basedir = '.'
            appenddir = ''
        else:
            appenddir = basedir
        try:
            for c in os.listdir(basedir):
                ok = True
                if len(appenddir) == 0:
                    ofile = c
                else:
                    ofile = os.path.join(basedir,c)
                if filterop is not None:
                    ok = filterop(ofile)
                if ok and (len(pathpat) == 0 or ofile.startswith(pathpat)):
                    retfiles.append(ofile)
        except:
            # nothing to handle 
            retfiles = []
        return retfiles


    def call_completion_cmd_nargs(self,cmdname,params):
        addmost = -1
        filtername = ''
        if len(params) > 1:
            filtername = params[-1]
        argsattr = self.__get_argsattr(cmdname)
        if argsattr is not None:
            if argsattr.nargs != '+' and argsattr.nargs != '*':
                if argsattr.nargs == '?':
                    addmost = 1
                else:
                    addmost = argsattr.nargs
        retcompletions = []
        if addmost >= 0 and addmost < len(self.leftargs):
            return retcompletions
        if argsattr.attr is not None and argsattr.attr.completefunc is not None:
            retcompletions.extend(self.call_func(argsattr.attr.completefunc,self,cmdname,params))
            return
        curcompletions = self.file_common_completion(filtername,None)
        curcompletions = sorted(curcompletions)
        for c in curcompletions:
            if c.startswith(filtername):
                retcompletions.append(c)
        return retcompletions     


    def completion_call_cmd(self,cmdname,params):
        filtername = ''
        validx = 1
        if len(params) > 1:
            filtername = params[-1]
            validx = len(params) - 1
        retcompletions = []
        hasstepped = False
        if len(filtername) > 0 and filtername.startswith(self.options.shortprefix) \
            and not filtername.startswith(self.options.longprefix) and self.options.bundled:
            idx = len(self.options.shortprefix)
            while idx < len(filtername):
                curch = filtername[idx]
                opt = self.__get_opt_shortflag(curch,cmdname)
                if opt is not None:
                    step = self.call_step_func(validx,opt,params,False)
                    if step > 0:
                        hasstepped = True
                idx += 1
        curcompletions = []

        for l in self.__get_longopts(cmdname):
            if l.startswith(filtername):
                curcompletions.append(l)
        curcompletions = sorted(curcompletions)
        retcompletions.extend(curcompletions)
        curcompletions = []
        if self.options.bundled and self.options.shortprefix is not None:
            if len(filtername) == 0:
                for c in self.__get_shortflags(cmdname):
                    curc = '%s%s'%(self.options.shortprefix,c)
                    curcompletions.append(curc)
            elif filtername.startswith(self.options.shortprefix) and not filtername.startswith(self.options.longprefix) :
                for c in self.__get_shortflags(cmdname):
                    added = True
                    opt = self.__get_opt_shortflag(c,cmdname)
                    if opt is not None and hasstepped:
                        step = self.call_step_func(validx,opt,params,False)
                        if step > 0:
                            added = False
                    if added :
                        curcompletions.append(c)
        elif self.options.shortprefix is not None:
            # this is not bundled ,so we do this ok
            for c in self.__get_shortflags(cmdname):
                curc = '%s%s'%(self.options.shortprefix,c)
                if curc.startswith(filtername):
                    curcompletions.append(curc)
        curcompletions = sorted(curcompletions)
        retcompletions.extend(curcompletions)
        subcmds = self.get_subcommands(cmdname)
        curcompletions = []
        if subcmds is not None:
            for c in subcmds:
                if c.startswith(filtername):
                    curcompletions.append(c)
        curcompletions = sorted(curcompletions)
        retcompletions.extend(curcompletions)
        curcompletions = self.call_completion_cmd_nargs(cmdname,params)
        curcompletions = sorted(curcompletions)
        retcompletions.extend(curcompletions)
        return retcompletions

    def completeion_call(self,validx,opt,params,endwords=''):
        retcompletions = []

        return retcompletions


    def __get_completions_cmdname(self,result,params,endwords=''):
        needopt = None
        if result.lastopt is not None and (result.lastidx < (len(params) - 1)):
            step = self.call_step_func(result.lastidx,result.lastopt,params)
            if   (result.lastidx + step) >= len(params):
                # this means that we have not handled all the needed
                needopt = result.lastopt
        if needopt is not None:
            # it means that we need to handle specified handle
            return self.completeion_call(result.lastidx,result.lastopt,params,endwords)
        return self.completion_call_cmd(result.cmdname,params)


    def get_completions(self,args=[],endwords=''):
        self.leftargs = []
        result = self.step_completes(args)
        logging.info('leftargs (%s)'%(self.leftargs))
        completions = []
        if result.stopped:
            return completions


        completions = self.__get_completions_cmdname(result,args,endwords='')
        return completions


                

##############################
##  this is the code for extended ,so
##  we should make this ok
##############################
extended_opt_code=''

def __get_priority(inputprior):
    priority = None
    if len(inputprior) == 0 or (len(inputprior) == 1 and inputprior[0] == 'NONE'):
        pass
    else:
        priority = []
        for c in inputprior:
            if c == 'SUBCMD_JSON' :
                priority.append(extargsparse.SUB_COMMAND_JSON_SET)
            elif c == 'CMD_JSON' :
                priority.append(extargsparse.COMMAND_JSON_SET)
            elif c == 'ENV_SUBCMD_JSON' :
                priority.append(extargsparse.ENV_SUB_COMMAND_JSON_SET)
            elif c == 'ENV_CMD_JSON':
                priority.append(extargsparse.ENV_COMMAND_JSON_SET)
            elif c == 'ENV_CMD' :
                priority.append(extargsparse.ENVIRONMENT_SET)
            elif c == 'NONE':
                break
            else:
                raise Exception('unknown priority (%s)'%(c))
    return priority


def completion_format(args):
    s = ''
    if args.jsonstr is None:
        args.jsonstr = read_file(args.jsonfile)
    if args.optfile is not None:
        args.options = read_file(args.optfile)
    logging.info('jsonstr (%s)'%(args.jsonstr))
    extoptions = extargsparse.ExtArgsOptions(args.options)
    priority = None
    if extoptions.priority is not None:
        priority = __get_priority(extoptions.priority)
    argsopt = CompleteExtArgs(extoptions,priority)
    argsopt.load_command_line_string(args.jsonstr)
    completions = argsopt.get_completions(args.subnargs)
    for l in completions:
        s += '%s\n'%(l)    
    return s    




def get_full_trace_back(trback,tabs=1,cnt=0):
    s = ''
    frm = getattr(trback,'tb_frame',None)
    if frm is not None:
        code = getattr(frm,'f_code',None)
        if code is not None:
            s += ' ' * tabs * 4
            s += '[%d][%s:%s:%s]\n'%(cnt,code.co_filename,code.co_name,frm.f_lineno)
            ntrace = getattr(trback,'tb_next',None)
            if ntrace is not None:
                s += get_full_trace_back(ntrace,tabs,cnt+1)
    return s

def set_log_level(args):
    loglvl= logging.ERROR
    if args.verbose >= 3:
        loglvl = logging.DEBUG
    elif args.verbose >= 2:
        loglvl = logging.INFO
    elif args.verbose >= 1 :
        loglvl = logging.WARN
    if logging.root is not None and len(logging.root.handlers) > 0:
        logging.root.handlers = []
    # we delete old handlers ,and set new handler
    logging.basicConfig(level=loglvl,format='%(asctime)s:%(filename)s:%(funcName)s:%(lineno)d\t%(message)s')
    return

def get_ver_tuple(ver):
    sarr = re.split('\.',ver)
    i = 0
    while i < len(sarr):
        sarr[i] = int(sarr[i])
        i += 1
    return sarr

def check_extargs_version(verleast):
    try:
        vernum = extargsparse.__version__
        leasttuple = get_ver_tuple(verleast)
        vertuple = get_ver_tuple(vernum)
        ok = True
        if vertuple[0] < leasttuple[0]:
            ok = False
        elif vertuple[0] == leasttuple[0]:
            if vertuple[1] < leasttuple[1]:
                ok = False
            elif vertuple[1] == leasttuple[1]:
                if vertuple[2] < leasttuple[2]:
                    ok = False              
        if not ok :
            raise Exception('version %s < %s'%(vernum,verleast))
    except:
        raise Exception('must at lease %s version of extargsparse'%(verleast))
    return

def complete_handler(args,parser):
    set_log_level(args)
    if args.debugmode:
        s = completion_format(args)
    else:
        try:        
            s = completion_format(args)
        except:
            trback = sys.exc_info()[2]
            exceptname = sys.exc_info()[1]
            s = ''
            s += 'exception %s:\n'%(exceptname)
            s +='trace back:\n'
            s += get_full_trace_back(trback,1,0)
            sys.stderr.write('%s'%(s))
            return
    output_string(s,args.output)
    sys.exit(0)
    return

def main():
    commandline='''
    {
        "verbose|v" : "+",
        "input|i" : null,
        "reserved|R##to reserve temp file##" : false,
        "jsonparse|j##if not set ,input json string from jsonfile or stdin##" : null,
        "jsonfile|J" : null,
        "output|o" : null,
        "options|O" : null,
        "optfile|F" : null,
        "debugmode|d" : false,
        "complete<complete_handler>" : {
            "$" : "*"
        }
    }
    '''
    check_extargs_version('1.0.0')
    parser = extargsparse.ExtArgsParse(None,[])
    parser.load_command_line_string(commandline)
    args = parser.parse_command_line()
    sys.stderr.write('can not get subcommand %s'%(args.subcommand))
    return

if __name__ == '__main__':
    main()